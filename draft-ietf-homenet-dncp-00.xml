<?xml version='1.0' ?>
<!--
Created:       Mon Nov 18 17:55:22 2013 mstenber

split from draft-ietf-homenet-hncp-03-pre - generic parts

-->

<!DOCTYPE rfc SYSTEM 'rfc2629.dtd'>

<?rfc autobreaks="yes"?>
<?rfc compact="yes"?>
<?rfc strict='yes'?>
<?rfc subcompact="no"?>
<?rfc symrefs="yes"?>
<?rfc toc="yes"?>
<?rfc tocindent="yes"?>

<rfc
    ipr='trust200902'
    docName='draft-ietf-homenet-dncp-00'
    category='std'
    >
  <front>
    <title abbrev="Distributed Node Consensus Protocol">
      Distributed Node Consensus Protocol
    </title>
    <author initials="M" surname="Stenberg" fullname="Markus Stenberg">
      <address>
        <postal>
          <street/>
          <city>Helsinki</city>
          <code>00930</code>
          <country>Finland</country>
        </postal>
        <email>markus.stenberg@iki.fi</email>
      </address>
    </author>
    <author initials="S" surname="Barth" fullname="Steven Barth">
      <address>
        <postal>
          <street/>
          <city>Halle</city>
          <code>06114</code>
          <country>Germany</country>
        </postal>
        <email>cyrus@openwrt.org</email>
      </address>
    </author>
    <date month="January" year="2015" />

    <area>Internet</area>
    <workgroup>Homenet Working Group</workgroup>
    <keyword>Homenet</keyword>
    <abstract>

      <t>This document describes the Distributed Node Consensus Protocol
      (DNCP), a generic state synchronization protocol which uses Trickle
      and Merkle trees. DNCP is transport agnostic and leaves some of the
      details to be specified in profiles, which define actual
      implementable DNCP based protocols. </t>

    </abstract>
  </front>
  <middle>
    <section title="Introduction">

      <t>DNCP is designed to provide a way for nodes to publish data
      consisting of an ordered set of TLV (Type-Length-Value) tuples and
      to receive the data published by all other reachable DNCP nodes.</t>

      <t>DNCP has relatively few requirements for the underlying transport;
      it requires some way of transmitting either unicast datagram or
      stream data to a DNCP peer and, if used in multicast mode, a way of
      sending multicast datagrams. If security is desired and one of the
      built-in security methods is to be used, support for some TLS-derived
      transport scheme - such as <xref target="RFC5246">TLS</xref> on top of
      TCP or <xref target="RFC6347">DTLS</xref> on top of UDP - is also
      required. </t>

    </section>

    <section anchor="kwd" title='Requirements Language'>

      <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL
      NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED",  "MAY", and
      "OPTIONAL" in this document are to be interpreted as described in
      <xref target='RFC2119'>RFC 2119</xref>.</t>

    </section>

    <section title="Terminology">
      <t>A DNCP profile is a definition of a set of rules and
      values listed in <xref target="profile-bits"/> specifying the
      behavior of a DNCP based protocol, such as the used transport
      method.  For readability, any DNCP profile specific parameters
      with a profile-specific fixed value are prefixed with DNCP_.</t>

      <t>A DNCP node is a single node which runs a protocol
      based on a DNCP profile.</t>

      <t>The DNCP network is a set of DNCP nodes running the same DNCP profile
      that can reach each other, either via learned shared connections in
      the underlying network, or using each other's addresses learned via
      other means. As DNCP exchanges are bidirectional, DNCP nodes
      connected via only unidirectional links are not considered
      connected. </t>

      <t>The node identifier is an opaque fixed-length identifier consisting of
      DNCP_NODE_IDENTIFIER_LENGTH bytes which uniquely identifies a DNCP
      node within a DNCP network. </t>

      <t>A link indicates a link-layer media over which directly connected
      nodes can communicate.</t>

      <t>An interface indicates a port of a node that is connected to a
      particular link. </t>

      <t>A connection denotes a locally configured use of DNCP on a DNCP
      node, that is attached either to an interface, to a specific remote
      unicast address to be contacted, or to a range of remote unicast
      addresses that are allowed to contact.</t>

      <t>The connection identifier is a 32-bit opaque value, which identifies a
      particular connection of that particular DNCP node. The value 0 is
      reserved for DNCP and sub-protocol purposes in the TLVs, and MUST NOT
      be used to identify an actual connection. This definition is in sync
      with <xref target="RFC3493"/>, as the non-zero small positive
      integers should comfortably fit within 32 bits.</t>

      <t>A (DNCP) peer refers to another DNCP node with which
      a DNCP node communicates directly on a particular connection.</t>

      <t>The node data is a set of TLVs published by a node in
      the DNCP network. Whole "node data" is owned by the node that
      publishes it, and it MUST be passed along as-is, including TLVs
      unknown to the forwarder.</t>

      <t>The node state is a set of metadata attributes for node data.  It
      includes a sequence number for versioning, a hash value for comparing
      and a timestamp indicating the time passed since its last
      publication. The hash function and the number of bits used are
      defined in the DNCP profile. </t>

      <t>The network state (hash) is a hash value which represents
      the current state of the network.  The hash function and the number of
      bits used are defined in the DNCP profile.

      Whenever any node is added, removed or changes its published node
      data this hash value changes as well. It is calculated over the
      hash values of each reachable nodes' node data in ascending order
      of the respective node identifier.</t>

      <t>The effective (trust) verdict for a certificate is defined as the
      verdict with the highest priority within the set of verdicts
      announced for the certificate in the DNCP network.</t>

      <t>The neighbor graph is the undirected graph of DNCP nodes produced
      by retaining only bidirectional peer relationships between nodes.</t>

    </section>

    <section anchor="dm" title="Data Model">

      <t>A DNCP node has:
      <list style="symbols">

        <t>A timestamp indicating the most recent neighbor graph traversal
        described in <xref target="purge" />.</t>

      </list>
      </t>

      <t>A DNCP node has for every DNCP node in the DNCP network:

      <list style="symbols">

        <t>A node identifier, which uniquely identifies the node.</t>

        <t>The node data, an ordered set of TLV tuples published by that
        particular node. This set of TLVs has a well-defined order based on
        ascending binary content (including TLV type and length). This
        facilitates linear time state delta processing. </t>

        <t>The latest update sequence number, a 32 bit number that is
        incremented any time the TLV set is published. For comparison
        purposes, a looping comparison should be used to avoid problems in
        case of overflow. An example would be: a &lt; b &lt;=&gt; (a - b)
        % 2^32 &amp; 2^31 != 0.</t>

        <t>The relative time (in milliseconds) since the current TLV data
        set with the current update sequence number was published. It is
        also a 32 bit number on the wire.  If this number is close to
        overflow (greater than 2^32-2^16), a node MUST re-publish its TLVs
        even if there is no change to avoid overflow of the value. In other
        words, absent any other changes, the TLV set MUST be re-published
        roughly every 49 days.</t>

        <t>A timestamp identifying the time it was last reachable based on
        neighbor graph traversal described in <xref target="purge" />.</t>

      </list>
      </t>

      <t>Additionally, a DNCP node has a set of connections for which DNCP
      is configured to be used. For each such connection, a node has:

      <list style="symbols">
        <t>A connection identifier.</t>

        <t>An interface, a unicast address of a DNCP peer it should
        connect with, or a range of addresses from which DNCP peers are
        allowed to connect.</t>

        <t>A <xref target="RFC6206">Trickle</xref> instance with parameters
        I, T, and c.</t>
      </list>
      </t>

      <t>For each DNCP peer detected on a connection, a DNCP node has:

      <list style="symbols">

        <t>The node identifier of the DNCP peer.</t>

        <t>The connection identifier of the DNCP peer.</t>

        <t>The most recent address used by the DNCP peer (in an
        authenticated message, if security is enabled).</t>

      </list>
      </t>

    </section>

    <section title="Operation">

      <t>The DNCP protocol consists of <xref target="RFC6206">Trickle</xref>
      driven unicast or multicast status messages which indicate the current
      status of shared TLV data and additional unicast message exchanges
      which ensure DNCP peer reachability and synchronize the data when
      necessary. </t>

      <t>If DNCP is to be used on a multicast-capable interface, as opposed
      to only point-to-point using unicast, a datagram-based transport
      which supports multicast SHOULD be defined in the DNCP profile to be
      used for the messages to be sent to the whole link. As this is used
      only to identify potential new DNCP nodes and to notify that an
      unicast exchange should be triggered, the multicast transport does
      not have to be particularly secure.</t>

      <section title="Trickle-Driven Status Update Messages"
               anchor="trickle-updates">

        <t>Each node MUST send either a <xref
        target="long-net-message">Long Network State Update message</xref>
        or a <xref target="short-net-message">Short Network State Update
        message</xref> every time the connection-specific <xref
        target="RFC6206">Trickle algorithm</xref> instance indicates that
        an update should be sent.
        The destination address of the message should be multicast in case
        of an interface which is multicast-capable, or the unicast address
        of the remote party in case of a point-to-point connection.

        By default, Long Network State Update messages SHOULD be used, but
        if it is defined as undesirable for some case by the DNCP profile,
        Short Network State Update message MUST be sent instead. This may
        be useful to avoid fragmenting packets to multicast destinations,
        or for security reasons.</t>

        <t>A Trickle state MUST be maintained separately for each
        connection. The Trickle state for all connections is considered
        inconsistent and reset if and only if the locally calculated
        network state hash changes. This occurs either due to a change in
        the local node's own node data, or due to receipt of more recent
        data from another node.</t>

        <t>The Trickle algorithm has 3 parameters: Imin, Imax and k. Imin
        and Imax represent the minimum and maximum values for I, which is
        the time interval during which at least k Trickle updates must be
        seen on a connection to prevent local state transmission.  The
        actual suggested Trickle algorithm parameters are DNCP profile
        specific, as described in <xref target="profile-bits"/>.</t>

      </section>

      <section title="Processing of Received Messages" anchor="reception">

        <t>This section describes how received messages are processed.  The
        DNCP profile may specify criteria based on which received messages
        are ignored. Any 'reply' mentioned in the steps below denotes
        sending of the specified message via unicast to the originator of
        the message being processed. If the reply was caused by a multicast
        message and sent to a link with shared bandwidth it SHOULD be
        delayed by a random timespan in [0, Imin/2]. Sending of replies
        SHOULD be rate-limited by the implementation, and in case of excess
        load (or some other reason), a reply MAY be omitted altogether. </t>

        <t>Upon receipt of:
        <list>

          <t><xref target="short-net-message">Short Network State
          Update</xref>:

          If the network state hash within the message differs from the
          locally calculated network state hash, the receiver MUST reply
          with a <xref target="req-net-message">Network State Request
          message</xref>.
          </t>

          <t><xref target="long-net-message">Long Network State
          Update</xref>:

          <list style="symbols">
            <t>If the network state hash within the message matches the
            locally calculated network state hash, stop processing.</t>

            <t>Otherwise the receiver MUST identify all nodes for which local
            information is outdated (local update sequence number is lower
            than that within the message), potentially incorrect (local
            update sequence number matches but the hash of the node data TLV
            differs) or missing.</t>

            <t>If any such nodes are identified, the receiver MUST reply
            with one or more <xref target="req-node-message">Node Data
            Request message(s)</xref> containing <xref
            target="req-node-data">Request Node Data TLV(s)</xref> for the
            corresponding nodes.</t>

          </list>
          </t>

          <t><xref target="req-net-message">Network State Request</xref>:
          the receiver MUST reply with a <xref
          target="long-net-message">Long Network State Update</xref>. </t>

          <t><xref target="req-node-message">Node Data Request</xref>: the
          receiver MUST reply with the requested data in a <xref
          target="reply-node-message">Node Data Reply
          message</xref>. Optionally - if specified by the DNCP profile -
          multiple replies MAY be sent in order to e.g. keep size of each
          datagram within the PMTU to the destination. However these
          replies must be valid stand-alone Node Data Reply messages, with
          the full state for the particular nodes.</t>

          <t><xref target="reply-node-message">Node Data Reply</xref>: If
          the message contains Node State TLVs that are more recent than
          the local state (the received TLV has a higher update sequence
          number, the node data TLV hash differs from the local one, or
          local data is missing altogether) and if the message also
          contains corresponding Node Data TLVs, the receiver MUST update
          its locally stored state.</t>
        </list>
        </t>

        <t>If a message containing <xref target="node-state">Node State
        TLVs</xref> is received with the node identifier matching the local
        node identifier and a higher update sequence number than its
        current local value, or the same update sequence number and a
        different hash, the node SHOULD re-publish its own node data with an
        update sequence number 1000 higher than the received one. This may
        occur normally once due to the local node restarting and not storing
        the most recently used update sequence number. If this occurs more
        than once, the DNCP profile should provide guidance on how to
        handle these situations as it indicates the existence of another
        active node with the same node identifier.</t>

      </section>

      <section title="Adding and Removing Peers" anchor="neighbor">

        <t>When receiving a message on a connection from an unknown peer:
        <list>
          <t>If it is a unicast message, and the message contains a <xref
          target="node-id">Node Connection TLV</xref>, the remote node MUST
          be added as a peer on the connection and a <xref
          target="neighbor-tlv">Neighbor TLV</xref> MUST be created for it.
          </t>

          <t>If it is a multicast message, and the message contains a <xref
          target="node-id">Node Connection TLV</xref>, the remote node
          SHOULD be sent a (possibly rate-limited) unicast <xref
          target="req-net-message">Network State Request
          Message</xref>.</t>
        </list>
        </t>

        <t>If keep-alives are NOT sent by the peer (either the DNCP profile
        does not specify the use of keep-alives or the particular peer chooses
        not to send keep-alive messages), some other means MUST be employed
        to ensure a DNCP peer is present. When the peer is no longer
        present, the Neighbor TLV and the local DNCP peer state MUST be
        removed.</t>
      </section>

      <section anchor="purge" title="Purging Unreachable Nodes">

        <t>When a Neighbor TLV or a whole node is added or removed, the
        neighbor graph SHOULD be traversed, starting from the local
        node. The edges to be traversed are identified by looking for
        Neighbor TLVs on both nodes, that have the other node's identifier
        in the neighbor node identifier, and local and neighbor connection
        identifiers swapped. Each node reached should be marked currently
        reachable.</t>

        <t>DNCP nodes MUST be either purged immediately when not marked
        reachable in a particular graph traversal, or eventually after they
        have not been marked reachable within DNCP_GRACE_INTERVAL. During
        the grace period, the nodes that were not marked reachable in the
        most recent graph traversal MUST NOT be used for calculation of the
        network state hash, be provided to any applications that need to
        use the whole TLV graph, or be provided to remote nodes. </t>

      </section>

    </section>

    <section anchor="ka" title="Keep-Alive Extension">

      <t>The Trickle-driven messages provide a mechanism for handling of
      new peer detection (if applicable) on a connection, as well as state
      change notifications. Another mechanism may be needed to get rid of
      old, no longer valid DNCP peers if the transport or lower layers do
      not provide one.</t>

      <t>If keep-alives are not specified in the DNCP profile, the rest of
      this section MUST be ignored.</t>

      <t>A DNCP profile MAY specify either per-connection or per-peer
      keep-alive support. </t>

      <t>For every connection that a keep-alive is specified for in the
      DNCP profile, the connection-specific keep-alive interval MUST be
      maintained. By default, it is DNCP_KEEPALIVE_INTERVAL. If there is a
      local value that is preferred for that for any reason (configuration,
      energy conservation, media type, ..), it should be substituted
      instead. If non-default keep-alive interval is used on any
      connection, a DNCP node MUST publish appropriate <xref
      target="ka-interval">Keep-Alive Interval TLV(s)</xref>.</t>

      <section title="Data Model Additions">

        <t>The following additions to the <xref target="dm">Data
        Model</xref> are needed to support keep-alive:</t>

        <t>Each node MUST have a timestamp which indicates the last time a
        <xref target="net-state">Network State TLV</xref> was sent for each
        connection, i.e. on an interface or to the point-to-point
        peer(s).</t>

        <t>Each node MUST have for each peer:

        <list style="symbols">

          <t>Last consistent state timestamp: a timestamp which indicates
          the last time a consistent <xref target="net-state">Network State
          TLV</xref> was received from the peer. When adding a new peer, it
          should be initialized to the current time.</t>

        </list>
        </t>

      </section>

      <section title="Per-Connection Periodic Keep-Alive Messages">

        <t>If per-connection keep-alives are enabled on a connection, and
        if no traffic containing a <xref target="net-state">Network State
        TLV</xref> has been sent to a particular connection within the
        connection-specific keep-alive interval, a <xref
        target="long-net-message">Long Network State Update message</xref>
        or a <xref target="short-net-message">Short Network State Update
        message</xref> MUST be sent on that connection. The type of message
        should be chosen based on the considerations in <xref
        target="trickle-updates" />. The actual sending time SHOULD be
        further delayed by a random timespan in [0, Imin/2].  When such a
        message is sent, a new Trickle transmission time 't' in [I/2, I]
        MUST be randomly chosen.</t>

      </section>

      <section title="Per-Peer Periodic Keep-Alive Messages">

        <t>If per-peer keep-alives are enabled on a connection, and if no
        traffic containing a <xref target="net-state">Network State
        TLV</xref> has been sent to a particular peer within the
        connection-specific keep-alive interval, a <xref
        target="long-net-message">Long Network State Update message</xref>
        or a <xref target="short-net-message">Short Network State Update
        message</xref> MUST be sent on that connection to the peer. The
        type of message should be chosen based on the considerations in
        <xref target="trickle-updates" />. When such a message is sent, a
        new Trickle transmission time 't' in [I/2, I] MUST be randomly
        chosen.</t>

      </section>

      <section title="Received Message Processing Additions">

        <t>If a message is received via unicast from the peer, the Last
        consistent state timestamp for the peer MUST be updated.</t>

        <t>If the received multicast message contains a <xref
        target="net-state">Network State TLV</xref> which is consistent
        with the locally calculated network state hash, the Last consistent
        state timestamp for the peer MUST be updated. If the TLV is
        inconsistent, and would not cause any unicast exchange, <xref
        target="req-net-message">Network State Request</xref> SHOULD be
        sent via unicast.</t>

      </section>

      <section title="Neighbor Removal">

        <t>For every peer on every connection, the connection-specific
        keep-alive interval must be calculated by looking for <xref
        target="ka-interval">Keep-Alive Interval TLVs</xref> published by
        the node, and if none exist, using the default value of
        DNCP_KEEPALIVE_INTERVAL. If the peer's last consistent state
        timestamp has not been updated for at least
        DNCP_KEEPALIVE_MULTIPLIER times the peer's connection-specific
        keep-alive interval, the Neighbor TLV for that peer and the local
        DNCP peer state MUST be removed.</t>

      </section>

    </section>

    <section title="Support For Dense Broadcast Links">

      <t>DNCP profile or user configuration should limit the number of
      neighbors that is the upper bound for a (particular type of) link
      that a connection runs on. If that bound is exceeded, all nodes
      without highest Node Identifier on the link MUST treat the connection
      as unicast connection with the node that has the highest Node
      Identifier detected on the link, but keep listening to multicast
      traffic to both detect presence of that node, and to react to new,
      higher Node Identifier nodes appearing. If the highest Node
      Identifier present on the link changes, the connection endpoint
      MUST be changed. If the Node Identifier of the local node is the
      highest one, the node MUST keep the connection in normal multicast
      mode, and it MUST attempt to peer with all nodes on the link.</t>

    </section>

    <section title="Protocol Messages">

      <t>For point-to-point exchanges, DNCP can run across
      datagram-based or reliable ordered stream-based transports.
      If a stream-based transport is used, a 32-bit length-value
      in network byte order is sent before each message to indicate the
      number of bytes the following message consists of.</t>

      <t>DNCP messages are encoded as a concatenated sequence of <xref
      target="tlvs">Type-Length-Value objects</xref>. In order to
      facilitate fast comparing of local state with that in a received
      message update, all TLVs in every encoding scope (either within the
      message itself, or within a container TLV) MUST be placed in
      ascending order based on the binary comparison of both TLV header
      and value. By design, the TLVs which MUST be present have the
      lowest available type values, ensuring they will naturally occur at
      the start of the Protocol Message, resembling a fixed format
      header.</t>

      <t>DNCP profiles MAY add additional TLVs to the message specified
      here, or even define additional messages as needed. TLVs not
      recognized by the receiver MUST be ignored.</t>

      <section title="Short Network State Update Message"
               anchor="short-net-message">

        <t>The Short Network State Update Message is used to announce the
        sender's view of the network state using multicast.</t>

        <t>The following TLVs MUST be present:
        <list style="symbols">

          <t>One <xref target="node-id">Node Connection TLV</xref> identifying
          the originating node and connection.</t>

          <t>One <xref target="net-state">Network State TLV</xref>
          containing the network state hash as calculated by the
          sender.</t>

        </list>
        </t>

        <t>The Short Network Status update message MUST NOT contain any
        <xref target="node-state">Node State TLV(s)</xref>.</t>

      </section>

      <section title="Long Network State Update Message"
               anchor="long-net-message">

        <t>The Long Network State Update Message is used to announce the
        sender's view of the network state and all node states using
        multicast or unicast.</t>

        <t>The following TLVs MUST be present:
        <list style="symbols">

          <t>One <xref target="node-id">Node Connection TLV</xref> identifying
          the originating node and connection.</t>

          <t>One <xref target="net-state">Network State TLV</xref>
          containing the network state hash as calculated by the
          sender.</t>

          <t>One or more <xref target="node-state">Node State TLVs</xref>
          containing the node state of DNCP nodes as currently known to the
          sender.</t>

        </list>
        </t>

        <t>The Long Network State Update message MUST include the
        corresponding <xref target="node-state">Node State TLV</xref> for
        each Node Data TLV used to calculate the network state hash.</t>

      </section>

      <section title="Network State Request Message"
               anchor="req-net-message">

        <t>The Network State Request message is used to request the
        recipient's view of the network state and all node states currently
        known to it.</t>

        <t>The following TLVs MUST be present:
        <list style="symbols">

          <t>One <xref target="req-net-state">Request Network State
          TLV</xref> indicating the type of request.</t>

        </list>
        </t>

      </section>

      <section title="Node Data Request Message"
               anchor="req-node-message">

        <t>The Node Data Request message is used to request the node state
        and data of one or more DNCP nodes in the network.</t>

        <t>The following TLVs MUST be present:
        <list style="symbols">

          <t>One or more <xref target="req-node-data">Request Node Data
          TLVs</xref> indicating the nodes for which state and data is
          requested.</t>

        </list>
        </t>

      </section>

      <section title="Node Data Reply Message"
               anchor="reply-node-message">

        <t>The Node Data Request message is used to provide
        the node data of one or more DNCP nodes in the network.</t>

        <t>The following TLVs MUST be present:
        <list style="symbols">

          <t>One <xref target="node-id">Node Connection TLV</xref> identifying
          the originating node and connection.</t>

          <t>One or more <xref target="node-state">Node State TLV</xref>
          and <xref target="node-data">Node Data TLV</xref> pairs with
          matching node identifiers for each node previously requested in a
          <xref target="req-node-message">Node Data Request
          message</xref>.</t>

        </list>
        </t>

      </section>
    </section>

    <section anchor="tlvs" title="Type-Length-Value Objects">
      <t>
        Each TLV is encoded as a 2 byte type field, followed by a 2 byte
        length field (of the value, excluding header; 0 means no value)
        followed by the value itself (if any). Both type and length fields
        in the header as well as all integer fields inside the value
        - unless explicitly stated otherwise - are
        represented in network byte order. Zero padding bytes MUST be added
        up to the next 4 byte boundary if the length is not divisible by 4.
        These padding bytes MUST NOT be included in the length field.
      </t>

      <figure>
        <artwork>
0                   1                   2                   3
0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|            Type               |           Length              |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                             Value                             |
|                     (variable # of bytes)                     |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        </artwork>
      </figure>

      <t>
        For example, type=123 (0x7b) TLV with value 'x' (120 =
        0x78) is encoded as: 007B 0001 7800 0000.
      </t>

      <t>Notation:
      <list>

        <t>.. = octet string concatenation operation.</t>

        <t>H(x) = non-cryptographic hash function specified by DNCP
        profile. </t>

      </list>
      </t>


      <section title="Request TLVs">

        <section anchor="req-net-state" title="Request Network State TLV">

          <figure>
            <artwork>
0                   1                   2                   3
0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|  Type: REQ-NETWORK-STATE (2)  |           Length: 0           |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            </artwork>
          </figure>

          <t>This TLV is used to identify a <xref
          target="req-net-message">Network State Request
          message</xref>.</t>

        </section>
        <section anchor="req-node-data" title="Request Node Data TLV">


          <figure>
            <artwork>
0                   1                   2                   3
0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|    Type: REQ-NODE-DATA (3)    |          Length: >0           |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                        Node Identifier                        |
|                  (length fixed in DNCP profile)               |
...
|                                                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            </artwork>
          </figure>

          <t>This TLV is used within a <xref target="req-node-message">Node
          Data Request message</xref> to request node state and node data
          for the node with matching node identifier, if any, to be
          included in a subsequent <xref target="reply-node-message">Node
          Data Reply message</xref>.</t>

        </section>

      </section>
      <section title="Data TLVs">
        <section anchor="node-id" title="Node Connection TLV">

          <figure>
            <artwork>
0                   1                   2                   3
0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|   Type: NODE-CONNECTION (1)   |          Length: > 4          |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                        Node Identifier                        |
|                  (length fixed in DNCP profile)               |
...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                     Connection Identifier                     |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            </artwork>
          </figure>

          <t>This TLV identifies both the local node's node identifier, as
          well as the particular connection identifier. It MUST be sent in
          all messages if bidirectional peer relationship is desired with
          remote nodes. Bidirectional peer relationship is not necessary
          for read-only access to the DNCP state, but it is required to be
          able to publish something.</t>

        </section>
        <section anchor="net-state" title="Network State TLV">

          <figure>
            <artwork>
0                   1                   2                   3
0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|    Type: NETWORK-STATE (10)   |          Length: > 0          |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|     H(H(node data TLV 1) .. [...] .. H(node data TLV N))      |
|                  (length fixed in DNCP profile)               |
...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            </artwork>
          </figure>

          <t>This TLV contains the current locally calculated network state
          hash. The network state hash is derived by calculating the hash
          value for each currently reachable node's Node Data TLV,
          concatenating said hash values based on the ascending order of
          their corresponding node identifiers, and hashing the resulting
          concatenated hash values.</t>

        </section>
        <section anchor="node-state" title="Node State TLV">

          <figure>
            <artwork>
0                   1                   2                   3
0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|      Type: NODE-STATE (11)    |          Length: > 8          |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                        Node Identifier                        |
|                  (length fixed in DNCP profile)               |
...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                    Update Sequence Number                     |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                Milliseconds since Origination                 |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                        H(node data TLV)                       |
|                  (length fixed in DNCP profile)               |
...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            </artwork>
          </figure>

          <t>This TLV represents the local node's knowledge about the published
          state of a node in the DNCP network identified by the node identifier
          field in the TLV.</t>

          <t>The whole network should have roughly same idea about the time
          since origination of any particular published state. Therefore
          every node, including the originating one, MUST increment the
          time whenever it needs to send a Node State TLV for an already
          published Node Data TLV. This age value is not included within
          the Node Data TLV, however, as that is immutable and used to
          detect changes in the network state.</t>

        </section>
        <section anchor="node-data" title="Node Data TLV">

          <figure>
            <artwork>
0                   1                   2                   3
0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|      Type: NODE-DATA (12)     |         Length: > 4           |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                        node identifier                        |
|                  (length fixed in DNCP profile)               |
...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                    Update Sequence Number                     |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|            Nested TLVs containing node information            |
            </artwork>
          </figure>

        </section>

        <section anchor="neighbor-tlv"
                 title="Neighbor TLV (within Node Data TLV)">
          <figure>
            <artwork>
0                   1                   2                   3
0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|       Type: NEIGHBOR (13)     |          Length: > 8          |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                    neighbor node identifier                   |
|                  (length fixed in DNCP profile)               |
...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                 Neighbor Connection Identifier                |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                   Local Connection Identifier                 |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            </artwork>
          </figure>

          <t>This TLV indicates that the node in question vouches that the
          specified neighbor is reachable by it on the specified local
          connection.

          The presence of this TLV at least guarantees that the node
          publishing it has received traffic from the neighbor
          recently. For guaranteed up-to-date bidirectional reachability,
          the existence of both nodes' matching Neighbor TLVs should be
          checked. </t>
        </section>

        <section anchor="ka-interval"
                 title="Keep-Alive Interval TLV (within Node Data TLV)">

          <figure>
            <artwork>
0                   1                   2                   3
0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
| Type: KEEP-ALIVE-INTERVAL (14)|          Length: 8            |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                     Connection Identifier                     |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                           Interval                            |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            </artwork>
          </figure>

          <t>This TLV indicates a non-default interval being used to send
          keep-alive messages specified in <xref target="ka" />.</t>

          <t>Connection identifier is used to identify the particular
          connection for which the interval applies. If 0, it applies for
          ALL connections for which no specific TLV exists.</t>

          <t>Interval specifies the interval in milliseconds at which the
          node sends keep-alives. A value of zero means no keep-alives are
          sent at all; in that case, some lower layer mechanism that
          ensures presence of nodes MUST be available and used. </t>
        </section>

      </section>

      <section anchor="user-tlv"
               title="Custom TLV (within/without Node Data TLV)">
        <figure>
          <artwork>
0                   1                   2                   3
0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|     Type: CUSTOM-DATA (15)    |         Length: > 0           |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                            H(URI)                             |
|                  (length fixed in DNCP profile)               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                          Opaque Data                          |
          </artwork>
        </figure>

        <t>This TLV can be used to contain anything; the URI used should be
        under control of the author of that specification.
        For example:</t>

        <t>V = H('http://example.com/author/json-for-dncp') .. '{"cool":
        "json extension!"}'</t>

        <t>or</t>

        <t>V = H('mailto:author@example.com') .. '{"cool": "json
        extension!"}'</t>

      </section>

    </section>


    <section title="Security and Trust Management">

      <t>If specified in the DNCP profile, either <xref
      target="RFC6347">DTLS</xref> or <xref target="RFC5246">TLS</xref> may
      be used to authenticate and encrypt either some (if specified
      optional in the profile), or all unicast traffic. The following
      methods for establishing trust are defined, but it is up to the DNCP
      profile to specify which ones may, should or must be supported.</t>


      <section title="Pre-Shared Key Based Trust Method">

        <t>A PSK-based trust model is a simple security management
        mechanism that allows an administrator to deploy devices to an
        existing network by configuring them with a pre-defined key,
        similar to the configuration of an administrator password or
        WPA-key.  Although limited in nature it is useful to provide a
        user-friendly security mechanism for smaller networks. </t>

      </section>

      <section title="PKI Based Trust Method">

        <t>A PKI-based trust-model enables more advanced management
        capabilities at the cost of increased complexity and
        bootstrapping effort. It however allows trust to be managed in a
        centralized manner and is therefore useful for larger networks
        with a need for an authoritative trust management.</t>

      </section>

      <section title="Certificate Based Trust Consensus Method">

        <t>The certificate-based consensus model is designed to be a
        compromise between trust management effort and flexibility. It is
        based on X.509-certificates and allows each DNCP node to provide a
        verdict on any other certificate and a consensus is found to
        determine whether a node using this certificate or any
        certificate signed by it is to be trusted. </t>

        <t>The current effective trust verdict for any certificate is
        defined as the one with the highest priority from all verdicts
        announced for said certificate at the time.</t>

        <section title="Trust Verdicts">

          <t>Trust Verdicts are statements of DNCP nodes about the
          trustworthiness of X.509-certificates.  There are 5 possible
          verdicts in order of ascending priority:

          <list style="hanging">

            <t hangText="0 Neutral">: no verdict exists but the DNCP
            network should determine one.</t>

            <t hangText="1 Cached Trust">: the last known effective verdict
            was Configured or Cached Trust.</t>

            <t hangText="2 Cached Distrust">: the last known effective
            verdict was Configured or Cached Distrust.</t>

            <t hangText="3 Configured Trust">: trustworthy based upon an
            external ceremony or configuration.</t>

            <t hangText="4 Configured Distrust">: not trustworthy based upon
            an external ceremony or configuration.</t>

          </list>
          </t>

          <t>
            Verdicts are differentiated in 3 groups:

            <list style="symbols">
              <t>Configured verdicts are used to announce explicit verdicts
              a node has based on any external trust bootstrap or
              predefined relation a node has formed with a given
              certificate.</t>

              <t>Cached verdicts are used to retain the last known trust
              state in case all nodes with configured verdicts about a
              given certificate have been disconnected or turned off.</t>

              <t>The Neutral verdict is used to announce a new node
              intending to join the network so a final verdict for it can
              be found.</t>
            </list>
          </t>

          <t>
            The current effective trust verdict for any certificate is
            defined as the one with the highest priority within the set of
            verdicts + announced for the certificate in the DNCP network.

            A node MUST be trusted for participating in the DNCP network if
            and only if the current effective verdict for its own
            certificate or any one in its certificate hierarchy is (Cached
            or Configured) Trust and none of the certificates in its
            hierarchy have an effective verdict of (Cached or Configured)
            Distrust.

            In case a node has a configured verdict, which is different
            from the current effective verdict for a certificate, the
            current effective verdict takes precedence in deciding
            trustworthiness. Despite that, the node still retains and
            announces its configured verdict.
          </t>
        </section>

        <section title="Trust Cache">

          <t>Each node SHOULD maintain a trust cache containing the current
          effective trust verdicts for all certificates currently announced
          in the DNCP network. This cache is used as a backup of the last
          known state in case there is no node announcing a configured
          verdict for a known certificate.  It SHOULD be saved to a
          non-volatile memory at reasonable time intervals to survive a
          reboot or power outage.</t>

          <t>Every time a node (re)joins the network or detects the change
          of an effective trust verdict for any certificate, it will
          synchronize its cache, i.e. store new effective verdicts
          overwriting any previously cached verdicts. Configured verdicts
          are stored in the cache as their respective cached counterparts.
          Neutral verdicts are never stored and do not override existing
          cached verdicts.</t>
        </section>

        <section title="Announcement of Verdicts">

          <t>A node SHOULD always announce any configured trust verdicts it
          has established by itself, and it MUST do so if announcing the
          configured trust verdict leads to a change in the current
          effective verdict for the respective certificate.  In absence of
          configured verdicts, it MUST announce cached trust verdicts it has
          stored in its trust cache, if one of the following conditions
          applies:

          <list style="symbols">
            <t>The stored verdict is Cached Trust and the current effective
            verdict for the certificate is Neutral or does not exist.</t>
            <t>The stored verdict is Cached Distrust and the current
            effective verdict for the certificate is Cached Trust.</t>
          </list>

          A node rechecks these conditions whenever it detects changes of
          announced trust verdicts anywhere in the network.
          </t>

          <t>Upon encountering a node with a hierarchy of certificates for
          which there is no effective verdict, a node adds a Neutral
          Trust-Verdict-TLV to its node data for all certificates found in
          the hierarchy, and publishes it until an effective verdict
          different from Neutral can be found for any of the certificates,
          or a reasonable amount of time (10 minutes is suggested) with no
          reaction and no further authentication attempts has passed.  Such
          verdicts SHOULD also be limited in rate and number to prevent
          denial-of-service attacks.</t>

          <t>Trust verdicts are announced using Trust-Verdict TLVs:
          <figure>
            <artwork>
0                   1                   2                   3
0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|   Type: Trust-Verdict (16)    |        Length: 37-100         |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|    Verdict    |                 (reserved)                    |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                                                               |
|                                                               |
|                                                               |
|                      SHA-256 Fingerprint                      |
|                                                               |
|                                                               |
|                                                               |
|                                                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                          Common Name                          |
            </artwork>
          </figure>

          <list>
            <t>Verdict represents the numerical index of the verdict.</t>

            <t>(reserved) is reserved for future additions and MUST be set
            to 0 when creating TLVs and ignored when parsing them.</t>

            <t>SHA-256 Fingerprint contains the <xref
            target="RFC6234">SHA-256</xref> hash value of the certificate
            in DER-format.</t>

            <t>Common Name contains the variable-length (1-64 bytes) common
            name of the certificate. Final byte MUST have value of 0.</t>
          </list>
          </t>
        </section>

        <section title="Bootstrap Ceremonies">
          <t>The following non-exhaustive list of methods describes
          possible ways to establish trust relationships between
          DNCP nodes and node certificates. Trust establishment is a
          two-way process in which the existing network must trust the
          newly added node and the newly added node must trust at least
          one of its neighboring nodes.

          It is therefore necessary that both the newly added node and an
          already trusted node perform such a ceremony to successfully
          introduce a node into the DNCP network.  In all cases an
          administrator MUST be provided with external means to identify
          the node belonging to a certificate based on its fingerprint
          and a meaningful common name.</t>

          <section title="Trust by Identification">
            <t>A node implementing certificate-based trust MUST provide
            an interface to retrieve the current set of effective trust
            verdicts, fingerprints and names of all certificates currently
            known and set configured trust verdicts to be
            announced. Alternatively it MAY provide a companion DNCP node
            or application with these capabilities with which it has a
            pre-established trust relationship.</t>
          </section>

          <section title="Preconfigured Trust">
            <t>A node MAY be preconfigured to trust a certain set of
            node or CA certificates.  However such trust relationships
            MUST NOT result in unwanted or unrelated trust for nodes not
            intended to be run inside the same network (e.g. all other
            devices by the same manufacturer).</t>
          </section>

          <section title="Trust on Button Press">
            <t>A node MAY provide a physical or virtual interface to put
            one or more of its internal network interfaces temporarily into
            a mode in which it trusts the certificate of the first
            DNCP node it can successfully establish a connection
            with.</t>
          </section>

          <section title="Trust on First Use">
            <t>A node which is not associated with any other DNCP node MAY
            trust the certificate of the first DNCP node it can
            successfully establish a connection with. This method MUST NOT
            be used when the node has already associated with any other
            DNCP node.</t>
          </section>
        </section>
      </section>
    </section>

    <section anchor="profile-bits" title="DNCP Profile-Specific Definitions">
      <!-- TBD - Pierre has a point - should define guidance on these,
           perhaps -->
      <t>Each DNCP profile MUST define following:
      <list style="symbols">

        <t>How the messages are secured:
        <list>
          <t>Not at all,</t>
          <t>optionally or always with the TLS scheme defined here using one or
          more of the methods, or</t>
          <t>with something else.</t>
        </list>

        Given that links with DNCP nodes can be sufficiently
        secured or isolated it is possible to run DNCP in a secure manner
        without using any form of authentication or encryption.
        </t>

        <t>Unicast and optionally multicast transport protocol(s) to be
        used. If TLS scheme within this document is to be used security,
        TLS or DTLS support for at least the unicast transport protocol is
        mandatory.</t>

        <t>Transport protocols' parameters such as port numbers to be used,
        or multicast address to be used. Unicast, multicast, and secure
        unicast may each require different parameters, if applicable. </t>

        <t>When receiving messages, what sort of messages are dropped, as
        specified in <xref target="reception" />.</t>

        <t>What is the criteria for sending Trickle-based <xref
        target="long-net-message">Long Network State Update message</xref>
        on an interface or to a DNCP peer.</t>

        <t>How to deal with node identifier collision as described in <xref
        target="reception" />. Main options are either for one or both
        nodes to assign new node identifiers to themselves, or to notify
        someone about a fatal error condition in the DNCP network.</t>

        <t>Imin, Imax and k ranges to be suggested for implementations to
        be used in the Trickle algorithm. The Trickle algorithm does not
        require these to be same across all implementations for it to work,
        but similar orders of magnitude helps implementations of a DNCP
        profile to behave more consistently and to facilitate estimation of
        lower and upper bounds for behavior of the network.</t>

        <t>Hash function H(x) to be used, and how many bits of the input
        are actually used. The chosen hash function is used to handle both
        hashing of node specific data, and network state hash, which is a
        hash of node specific data hashes. SHA-256 defined in <xref
        target="RFC6234" /> is the recommended default choice.</t>

        <t>DNCP_NODE_IDENTIFIER_LENGTH: The fixed length of a node
        identifier (in bytes).</t>

        <t>DNCP_GRACE_INTERVAL: How long node data for unreachable nodes is
        kept.</t>

        <t>Whether to send keep-alives, and if so, on an interface, using
        multicast, or directly using unicast to peers. Keep-alive has also
        associated parameters:

        <list style="symbols">
          <t>DNCP_KEEPALIVE_INTERVAL: How often keep-alive messages are to be
          sent by default (if enabled).</t>

          <t>DNCP_KEEPALIVE_MULTIPLIER: How many times the
          DNCP_KEEPALIVE_INTERVAL (or peer-supplied keep-alive interval
          value) a node may not be heard from to be considered still
          valid.</t>
        </list>
        </t>
      </list>
    </t>
  </section>

  <section title="Security Considerations">

    <t>DNCP profiles may use multicast to indicate DNCP state changes and
    for keep-alive purposes. However, no actual data TLVs will be sent
    across that channel. Therefore an attacker may only learn hash values
    of the state within DNCP and may be able to trigger unicast
    synchronization attempts between nodes on a local link this way. A DNCP
    node should therefore rate-limit its reactions to multicast
    packets.</t>

    <t>When using DNCP to bootstrap a network, PKI based solutions may have
    issues when validating certificates due to potentially unavailable
    accurate time, or due to inability to use the network to either check
    Certifcate Revocation Lists or perform on-line validation.</t>

    <t>The Certificate-based trust consensus mechanism defined in this
    document allows for a consenting revocation, however in case of a
    compromised device the trust cache may be poisoned before the actual
    revocation happens allowing the distrusted device to rejoin the network
    using a different identity.  Stopping such an attack might require
    physical intervention and flushing of the trust caches. </t>

  </section>

  <section anchor="iana" title="IANA Considerations">

    <t>IANA should set up a registry for DNCP TLV types,
    with the following initial contents:</t>

    <t>0: Reserved (should not happen on wire)</t>
    <t>1: Node connection</t>
    <t>2: Request network state</t>
    <t>3: Request node data</t>
    <t>4-9: Reserved for DNCP profile use</t>
    <t>10: Network state</t>
    <t>11: Node state</t>
    <t>12: Node data</t>
    <t>13: Neighbor</t>
    <t>14: Keep-alive interval</t>
    <t>15: Custom</t>
    <t>16: Trust-Verdict</t>
    <t>17-31: Reserved for future DNCP versions.</t>

    <t>192-255: Reserved for per-implementation experimentation. The
    nodes using TLV types in this range SHOULD use e.g. Custom TLV to
    identify each other and therefore eliminate potential conflict caused
    by potential different use of same TLV numbers. </t>

    <t>For the rest of the values (32-191, 256-65535), policy of 'standards
    action' should be used.</t>

  </section>

</middle>
<back>
  <references title="Normative references">
    <?rfc include="reference.RFC.2119.xml"?>
    <?rfc include="reference.RFC.6206.xml"?>
    <?rfc include="reference.RFC.6347.xml"?>
    <?rfc include="reference.RFC.5246.xml"?>
  </references>
  <references title="Informative references">
    <?rfc include="reference.RFC.3493.xml"?>
    <?rfc include="reference.RFC.6234.xml"?>
  </references>
  <section title="Some Outstanding Issues">

    <t>Should per-peer keep-alives be specified here? They are essentially
    constant unicast keep-alives, as opposed to unicast OR multicast
    per-connection ones are.</t>

    <t>Should better forms of combined messages be defined? e.g. allow
    sending both request-network-state, and currently set of known local
    state at same time in one message.</t>

  </section>

  <section title="Some Obvious Questions and Answers">

    <t>Q: Should there be nested container syntax that is actually
    self-describing? (i.e. type flag that indicates container, no body
    except sub-TLVs?)</t>

    <t>A: Not for now, but perhaps valid design.. TBD.</t>

    <t>Q: Add third case for multicast - 'medium' network state, which is
    'long' one, but partial?</t>

    <t>A: Drops typical convergence on large networks 5->3 packets, at
    expense of some specification/implementation complexity. However, as
    anything else than short network state leaks information via multicast,
    it does not seem worth it as secure protocols probably want to prevent
    multicast sending of anything else than short network state in any
    case. </t>

    <t>Q: 32-bit connection id?</t>

    <t>A: Here, it would save 32 bits per neighbor if it was 16 bits (and
    less is not realistic). However, TLVs defined elsewhere would not
    seem to even gain that much on average.  32 bits is also used for
    ifindex in various operating systems, making for simpler
    implementation.</t>

    <t>Q: Why not doing (performance thing X, Y or Z)?</t>

    <t>A: This is designed mostly to be minimal (only timers Trickle
    ones; everything triggered by Trickle-driven messages or local state
    changes). However, feel free to suggest better (even more minimal)
    design which works. </t>

  </section>
  <section title="Changelog">

    <t>draft-ietf-homenet-dncp-01:
    <list style="symbols">

      <t>Fixed keep-alive semantics to consider unicast requests also
      updates of most recently consistent, and added proactive unicast
      request to ensure even inconsistent keep-alive messages eventually
      triggering consistency timestamp update.</t>

      <t>Facilitated (simple) read-only clients by making Node Connection
      TLV optional if just using DNCP for read-only purposes.</t>

      <t>Added text describing how to deal with "dense" networks, but left
      actual numbers and mechanics up to DNCP profiles and (local)
      configurations.</t>
    </list>
    </t>

    <t>draft-ietf-homenet-dncp-00: Split from pre-version of
    draft-ietf-homenet-hncp-03 generic parts. Changes that affect
    implementations:
    <list style="symbols">

      <t>TLVs were renumbered.</t>

      <t>TLV length does not include header (=-4). This facilitates
      e.g. use of DHCPv6 option parsing libraries (same encoding), and
      reduces complexity (no need to handle error values of length less
      than 4).</t>

      <t>Trickle is reset only when locally calculated network state hash
      is changes, not as remote different network state hash is seen. This
      prevents e.g. attacks by multicast with one multicast packet to force
      Trickle reset on every interface of every node on a link.</t>

      <t>Instead of 'ping', use 'keep-alive' (optional) for dead peer
      detection. Different message used!</t>

    </list>
    </t>

  </section>

  <section title="Draft Source">
    <t>As usual, this draft is available at <eref
    target="https://github.com/fingon/ietf-drafts/">
    https://github.com/fingon/ietf-drafts/</eref>
    in source format (with nice Makefile too). Feel free to send comments
    and/or pull requests if and when you have changes to it! </t>
  </section>

  <section title="Acknowledgements">

    <t>Thanks to Ole Troan, Pierre Pfister, Mark Baugher, Mark Townsley,
    Juliusz Chroboczek and Jiazi Yi for their contributions to the
    draft.</t>

  </section>

</back>
</rfc>
