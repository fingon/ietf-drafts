<?xml version='1.0' ?>
<!--
Created:       Mon Nov 18 17:55:22 2013 mstenber
Last modified: Mon Dec  2 17:40:37 2013 mstenber
Edit time:     304 min
-->

<!DOCTYPE rfc SYSTEM 'rfc2629.dtd'>

<?rfc autobreaks="yes"?>
<?rfc compact="yes"?>
<?rfc strict='yes'?>
<?rfc subcompact="no"?>
<?rfc symrefs="yes"?>
<?rfc toc="yes"?>
<?rfc tocindent="yes"?>

<rfc
    ipr='trust200902'
    docName='draft-stenberg-homenet-hcp-00'
    category='std'
    >
  <front>
    <title abbrev="Homenet Control Protocol">
      Homenet Control Protocol
    </title>
    <author initials="M" surname="Stenberg" fullname="Markus Stenberg">
      <address>
        <postal>
          <street/>
          <city>Helsinki</city>
          <code>00930</code>
          <country>Finland</country>
        </postal>
        <email>markus.stenberg@iki.fi</email>
      </address>
    </author>
    <date month="November" year="2013" />

    <!--    <workgroup></workgroup> -->

    <keyword>IPv6</keyword>
    <keyword>Homenet</keyword>
    <abstract>

      <t>This document describes a minimal state flooding protocol for home
      (or other small site) use that can be used for various purposes,
      without being tied to particular routing protocol. </t>

    </abstract>
  </front>
  <middle>
    <section title="Introduction">

      <t>In a home (or small other site) with multiple routers, there is
      typically a need to share some state among the routers. There are two
      logical alternatives how this state can be shared:

      <list style="numbers">
        <t>
          Everything within routing protocol (the "huge routing protocol"
          assumption). Current set of drafts that have been
          promoted within the homenet working group
          seem to promote this as the way to go (e.g. <xref
          target="I-D.arkko-homenet-prefix-assignment"/>, <xref target="I-D.stenberg-homenet-dnssdext-hybrid-proxy-ospf"/>).
        </t>
        <t>
          Everything where it is needed (small, discrete pieces of
          functionality such as separate routing, service discovery, and
          prefix assignment daemons). 
        </t>
      </list>
      </t>

      <t>This draft describes a way to synchronize non-routing state across
      the network, enabling use of arbitrary set of routing protocols in a
      home as long as they support both importing and exporting of
      source-specific route entries required to get the functionality
      described in <xref target="I-D.troan-homenet-sadr"/>.</t>

    </section>

    <section title="Data model">

      <t>Data model of the hcp protocol is simple: Every participating node
      has (and also knows for every other participating node):
      <list>
        <t>An unique, possibly long node identifier (length doesn't matter
        very much, it's hash is mainly used). It can be a public
        key, or some other unique blob of binary data if signatures are not
        used.</t>

        <t>Latest update number (a 32-bit number).</t>

        <t>A set of TLV data it wants to share with the rest of the
        home. The TLVs are assumed to be sorted in ascending order based on
        their binary content. </t>
      </list>
      </t>
      
      <t>If signatures are in use, every node also has their own private
      key that corresponds with their public key. The private key is not
      shared across the network, but is instead used for signatures of
      messages and node state updates if desirable.</t>
    </section>

    <section title="Operation">

      <t>This protocol is designed to run on port TBD, using link-local
      scoped IPv6 UDP unicast and multicast messages to address TBD for
      transport.</t>

      <section title="Regular (trickle-driven) status update sending">

      <t>Every node is responsible for sending link-local multicast network
      state messages defined in <xref target="net-message"/> every time
      Trickle algorithm defined in <xref target="RFC6206"/> indicates
      they should on every link the protocol is active on.</t>

      <t>Trickle algorithm has 3 parameters; Imin, Imax and k. Imin and
      Imax represent minimum and maximum time intervals during which at
      least k Trickle update must be seen on a link. This specification
      does NOT mandate any defaults, but given the timer reset on data
      updates, k=1 SHOULD be used (as later retransmissions should handle
      packet loss in any case). Imax MUST be at least a minute. Imin MUST
      be at least 500 milliseconds to make this at least as
      network-unfriendly as Multicast DNS (earliest transmissions may occur
      at Imin/2 = 250 milliseconds given minimum values).</t>

      </section>

      <section title="Received packet handling">
        <t>
          <list style="numbers">

            <t>If it's multicast message:
            <list style="numbers">

              <t>Verify it's network state message defined in <xref
              target="net-message"/>, and treat Trickle state as consistent if
              and only if the network state hash matches local known state (If
              so, no need to proceed further). If not, treat Trickle state as
              inconsistent. </t>

              <t>If the message was in short format (no node state TLV(s)),
              send network state request defined in <xref
              target="req-net-message"/>.</t>

              <t>Otherwise send node state request defined in 
              <xref target="req-node-message"/> 
              for any nodes our information is outdated for (or missing). Note
              that if our information is more recent than the neighbor's, this
              may require sending nothing at all.
              </t>
            </list>
            </t>

            <t>If it's unicast message:
            <list style="numbers">

              <t>If it's request (either network state request defined in 
              <xref target="req-net-message"/> 
              , or node state request defined in 
              <xref target="req-node-message"/> 
              ), provide the required data in an unicast reply.
              </t>

              <t>If it's reply which contains node states that seem more
              recent than ours, send node state request defined in 
              <xref target="req-node-message"/> 
              for any nodes our information is outdated for (or missing).
              If it contains node data which is more recent than
              what we have, update our state and reset Trickle
              </t>

            </list>
            </t>
            
          </list>
        </t>
      </section>

      <section title="Data updates">

        <t>Each node is responsible for publishing only a valid set of data
        in TLVs. Whenever data node publishes changes, the update number
        should be incremented. If data for own node id is detected (via
        uni- or multicast message containing node state TLVs described in
        <xref target="node-state" />) with higher update # than current,
        own update number should be made higher and data republished. </t>

        <t>Regardless of how the node data for ANY node node has changes,
        any change should reset the Trickle timer.</t>
      </section>

      <section title="Removal of whole nodes">

        <t>Whenever trickle is in inconsistent state, nodes SHOULD do
        traversal of neighbor graph (by following the neighbor TLVs under
        link TLVs of node TLVs to other node TLVs), and 
        purge all node data for nodes which are no longer reachable. </t>
      </section>
      
      <section title="Neighbor state maintenance">
        <t>Whenever unicast reply is received on a link from another
        node, the node should be added as neighbor TLV for current
        node. If nothing (no RAs, no HCP traffic) is received from
        that neighbor in XXX seconds and the neighbor is not in ND
        cache, at least 3 attempts to ping it with request network
        state message defined in <xref target="req-net-message" />
        SHOULD be sent with increasing timeouts (e.g. 1, 2, 4
        seconds). If even after suitable period after the last message
        nothing is received, the neighbor TLV MUST be removed so that
        there are no dangling neighbors. </t>
      </section>

    </section>

    <section title="Messages">

        <t>Every message is encoded as a sequence of TLV
        objects described in <xref target="tlvs"/>. Therefore the message
        definition here defines just the set of TLVs expected in the
        particular message. 
        </t>
        
        <t>Note that in _every_ encoding scope (either root level within
        the message itself, or within container TLV), TLVs MUST be in
        ascending order based on binary comparison of both TLV header and
        value.</t>

      <section title="Network state message ((link-local) multicast)"
               anchor="net-message">
        <t>Must be present:
        <list>
          <t>node link TLV (defined in <xref target="node-id"/>).</t>
          <t>network state hash TLV (defined in <xref target="net-hash"/>).</t>
        </list>
        </t>

        <t>There may be also _all_ node state TLV(s) (defined in <xref
        target="node-state"/>), if and only if inserting all of them within
        the message would not exceed the minimum IPv6 MTU.</t>

        <t>May be present: certificate-related TLVs and signature
        TLV.</t>
      </section>

      <section title="Request network state message (unicast)"
               anchor="req-net-message">
        <t>Must be present:
        <list>
          <t>node link TLV (defined in <xref target="node-id"/>).</t>
          <t>request network state hash TLV (defined in <xref target="req-net-hash"/>).</t>
        </list>
        </t>

        <t>May be present: certificate-related TLVs and signature
        TLV.</t>

      </section>
      <section title="Request node(s) data message (unicast)"
               anchor="req-node-message">

        <t>Must be present:
        <list>
          <t>node link TLV  (defined in <xref target="node-id"/>).</t>
          <t>one or more request node data TLVs (defined in <xref
          target="req-node-data" />)).</t>
        </list>
        </t>

        <t>May be present: certificate-related TLVs and signature
        TLV.</t>

      </section>
      <section title="Reply state message (unicast)"
               anchor="reply-message">
        <t>Must be present:
        <list>
          <t>node link TLV  (defined in <xref target="node-id"/>).</t>

          <t>network state hash TLV (defined in <xref
          target="net-hash" />) and variable number of node state
          TLVs (defined in <xref target="node-state" />), or</t>

          <t>one or more combinations of node state and node data TLVs
          (defined in <xref target="node-data" />).</t>

        </list>
        </t>

        <t>May be present: certificate-related TLVs and signature
        TLV.</t>


      </section>
    </section>

    <section anchor="tlvs" title="Type-Length-Value objects">
      <t>
        Every TLV is encoded as 2 octet type, followed by 2 octet length
        (of the whole TLV, including header; 4 means no value whatsoever),
        and then followed by the value itself.

        The actual length of TLV is always divisible by 4; if the length is
        not, there are zeroed padding bytes at the end of TLV not included
        in the length field.

      </t>

      <figure>
        <artwork>
      0                   1                   2                   3
      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |            Type               |           Length              |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                             Value                             |
      |                     (variable # of bytes)                     |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
                                 TLV format
        </artwork>
      </figure>

      <t>
        Encoding of type=123 (0x7b) TLV with value 'x' (120 = 0x78):

        007B 0005 7800 0000
      </t>

      <t>Notation:
      <list>
        <t>.. = binary concatenation operation</t>
        <t>H(x) = hash function (TBD) of x</t>
        <t>H-64(x) = H(x) truncated by taking just first 64 bits of the result.</t>
      </list>
      </t>


      <section title="Request TLVs (for use within unicast requests)">

      <section anchor="req-net-hash" title="Request network state hash TLV">

        <t>TLV with T=1, empty V.</t>

      </section>
      <section anchor="req-node-data" title="Request node data TLV">

        <t>TLV with T=5, V=H(node identifier).</t>

      </section>

      </section>
      <section title="Data TLVs (for use in both multi- and unicast data)">
      <section anchor="net-hash" title="Network state hash TLV">

        <t>TLV with T=2, V=H(H(node data TLV 1) .. H(node data TLV N)).</t>
        
        <t>The node states are ordered according to normal ordering rules,
        that is, in ascending order, for hashing. </t>

      </section>
      <section anchor="node-id" title="Node link TLV">

        <t>TLV with T=3, V=H(node identifier) .. link id (4 octets)</t>

      </section>
      <section anchor="node-state" title="Node state TLV">

        <t>TLV with T=4, V=H(node identifier) .. update # (4 octets)
        .. milliseconds since origination (4 octets) .. H(node data TLV)</t>

        <t>Whole network should have the same idea about the time
        since origination; even the originating router should
        increment the time whenever it needs to send new node state
        TLV regarding itself without changing it's node data TLV. It
        is not included within node data TLV, however, as that is
        immutable and potentially signed by the originating node at
        the time of origination.</t>

      </section>
      <section anchor="node-data" title="Node data TLV">

        <t>TLV with T=6, V=H(node identifier) .. update # (4 octets) .. a
        set of sub-TLVs.</t>

        <t>Public key TLV (described in <xref target="node-pk-tlv" />
        SHOULD be always included if signatures are ever used. </t>
        <t>If signatures in use, the node data TLV SHOULD also contain
        originator's own signature TLV. </t>
      </section>


      <section anchor="node-pk-tlv" title="Node's public key TLV (within
                                           node data TLV)">
        <t>TLV with T=7, V=public key (=raw node identifier)</t>

        <t>Public key data for the node. Only relevant if signatures
        are used. Can be used to verify that H(node identifier) == public
        key, and that the node data signature matches public key. </t>

      </section>

      <section anchor="neighbor-tlv" title="Neighbor TLV (within node data TLV)">
        <t>TLV with T=8, V=H(neighbor node identifier)  .. neighbor link id (4 octets).. local link id (4 octets)</t>
        <t>This TLV indicates that the node in question vouches that
        the specified neighbor is reachable by it on the local link id
        given. </t>
      </section>
      </section>

      <section anchor="user-tlv" title="Custom TLV">
        <t>TLV with T=9, V=H-64(URI) .. opaque data</t>
        <t>This TLV can be used to contain anything; the URI used should be
        under control of the author of that specification. 
        For example:
        
        V=H-64('http://fingon.iki.fi/json-for-hcp') .. '{"cool": "json
        extension!"}'

        or

        V=H-64('mailto:fingon+json+hcp@iki.fi') .. '{"cool": "json
        extension!"}'

        </t>
      </section>


      <section title="Certificate-related TLVs">

        <t>TBD; should be probably some sort of certificate ID to be used
        in a lookup at most, as raw certificates will overflow easily IPv6
        minimum MTU.</t>

      </section>
      <section title="Signature TLV">

        <t>TLV with T=0xFFFF, V=(TBD) public key algorithm based signature
        of all TLVs within current scope. The assumed signature key is
        private key matching the public key of the the originator of node
        link TLV (if signature TLV is within main body of message), or that
        of the originator of the node data TLV (if signature TLV is within
        node data TLV)..</t>

      </section>
    </section>

    <section title="Security Considerations">
      <t>There are at least 3 ways in which this protocol can be deployed:

      <list>
        
        <t>Simplest model is "have faith" mode; no security, no
        signatures. Instead of public key, just some unique hardware
        fingerprint or something equivalent should be used. </t>
        
        <t>Slightly more trustworthy (as long as you trust every router in
        your home) is to use manually keyed IPsec using the per-port
        granularity for port TBD UDP traffic. The painful part in this mode
        is setting up the pre-shared key as IKE cannot be used with
        multicast traffic. </t>
        
        <t>If even every router cannot be trusted, or some more guarantees
        about source of particular node status updates is desired, real
        public and private keys should be used to create signatures and 
        verify them both on per-node data TLVs, as well as whole packet level.
        </t>
        
      </list>
      </t>
        
      <t>In the "have faith mode", the protocol is wide open to a variety
      of attacks. On the other hand, in the in-protocol cryptography mode,
      care must be taken in rate limiting verification of invalid packets,
      as otherwise denial of service may occur due to exhaustion of
      computation resources on a router. </t>

    </section>

    <section anchor="iana" title="IANA Considerations">
      
      <t>TBD (IANA should maintain registry of types)</t>

    </section>

  </middle>
  <back>
    <references title="Normative references">
      <?rfc include="reference.RFC.6206.xml"?>
    </references>
    <references title="Informative references">
      <?rfc include="reference.I-D.draft-troan-homenet-sadr-01.xml"?>
      <?rfc include="reference.I-D.draft-arkko-homenet-prefix-assignment-04.xml"?>
      <?rfc include="reference.I-D.draft-stenberg-homenet-dnssdext-hybrid-proxy-ospf-00.xml"?>
    </references>
    <section title="TODO">
      <t>Should define container TLV for ND/DHCP options.</t>
      <t>Consider if duplicate H(node identifier) detection should be
      included. On one hand, would allow for shorter H functions. On the
      other, complicates protocols and forces publishing of node identifier
      contents. </t>
      <t>Is there a case for non-linklocal unicast? Currently explicitly
      stating this is link-local only protocol.</t>
    </section>
    <section title="Q &amp; A">
      <t>Q: Why not use TCP?</t>
      <t>A: It doesn't address the discovery problem. It also leads to N^2
      connections when N nodes share a link, which is awkward. </t>


      <t>Q: Why effectively build a link state routing protocol without
      routing?</t>
      <t>A: It felt like a good idea at the time. It does not require
      periodic flooding except for very minimal Trickle-based per-link
      state maintenance (potentially also neighbor reachability checks if
      so desired).</t>

      <t>Q: Why not multicast-only?</t>
      <t>A: It would require defining application level fragmentation
      scheme. Hopefully the data amounts used will stay small so we just
      trust unicast UDP to handle 'big enough' packets to contain single
      node's TLV data.</t>

      <t>Q: Why so long IDs? Why real hash?</t>
      <t>A: Specifying conflict detection for smaller IDs was harder, and
      scalability of protocol isn't really affected by using real
      (=cryptographic) hash function.</t>

      <t>Q: Why trust IPv6 fragmentation in unicast case? Why not do L7
      fragmentation?</t>

      <t>A: Because it will be there for a while at least. And while PMTU
      et al may be problems on open internet, in controlled network
      environment UDP fragmentation should NOT be broken in the foreseeable
      future. </t>

      <t>Q: Should there be nested container syntax that is actually self-describing? (i.e. type flag that indicates container, no body except sub-TLVs?)</t>
      <t>A: Not for now, but perhaps valid design.. TBD.</t>
      

    </section>
    <section title="Draft source">
      <t>As usual, this draft is available at <eref
      target="https://github.com/fingon/ietf-drafts/">https://github.com/fingon/ietf-drafts/</eref>
      in source format (with nice Makefile too). Feel free to send comments
      and/or pull requests if and when you have changes to it! </t>
    </section>

    <section title="Acknowledgements">

      <t>Thanks to Ole Troan, Steven Barth and Pierre Pfister for review comments.</t>

    </section>
    
  </back>
</rfc>
