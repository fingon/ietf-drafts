<?xml version='1.0' ?>
<!--
Created:       Mon Nov 18 17:55:22 2013 mstenber
Last modified: Tue Nov 19 08:57:52 2013 mstenber
Edit time:     182 min
-->

<!DOCTYPE rfc SYSTEM 'rfc2629.dtd'>

<?rfc autobreaks="yes"?>
<?rfc compact="yes"?>
<?rfc strict='yes'?>
<?rfc subcompact="no"?>
<?rfc symrefs="yes"?>
<?rfc toc="yes"?>
<?rfc tocindent="yes"?>

<rfc
    ipr='trust200902'
    docName='draft-stenberg-homenet-hcp-00'
    category='std'
    >
  <front>
    <title abbrev="Homenet Control Protocol">
      Homenet Control Protocol
    </title>
    <author initials="M" surname="Stenberg" fullname="Markus Stenberg">
      <address>
        <postal>
          <street/>
          <city>Helsinki</city>
          <code>00930</code>
          <country>Finland</country>
        </postal>
        <email>markus.stenberg@iki.fi</email>
      </address>
    </author>
    <date month="November" year="2013" />

    <!--    <workgroup></workgroup> -->

    <keyword>IPv6</keyword>
    <keyword>Homenet</keyword>
    <abstract>

      <t>This document describes a minimal state flooding protocol for home
      (or other small site) use that can be used for various purposes,
      without being tied to particular routing protocol. </t>

    </abstract>
  </front>
  <middle>
    <section title="Introduction">

      <t>In a home (or small other site) with multiple routers, there is
      typically a need to share some state among the routers. There are two
      logical alternatives how this state can be shared:

      <list style="numbers">
        <t>
          Everything within routing protocol (the "huge routing protocol"
          assumption). Current set of drafts that have been
          promoted within the homenet working group
          seem to promote this as the way to go (e.g. <xref
          target="I-D.arkko-homenet-prefix-assignment"/>, <xref target="I-D.stenberg-homenet-dnssdext-hybrid-proxy-ospf"/>).
        </t>
        <t>
          Everything where it is needed (small, discrete pieces of
          functionality such as separate routing, service discovery, and
          prefix assignment daemons). 
        </t>
      </list>
      </t>

      <t>This draft describes a way to synchronize non-routing state across
      the network, enabling use of arbitrary set of routing protocols in a
      home as long as they support both importing and exporting of
      source-specific route entries required to get the functionality
      described in <xref target="I-D.troan-homenet-sadr"/>.</t>

    </section>

    <section title="Data model">

      <t>Data model of the hcp protocol is simple: Every participating node
      has (and also knows for every other participating node):
      <list>
        <t>A public key which identifies it.</t>

        <t>Latest update number (a 32-bit number).</t>

        <t>A set of TLV data it wants to share with the rest of the
        home. The TLVs are assumed to be sorted in ascending order based on
        their binary content. </t>
      </list>
      </t>
      
      <t>Every node also has their own private key that corresponds with
      their public key. The private key is not shared across the network,
      but is instead used for signatures of messages and node state
      updates if desirable.</t>
    </section>

    <section title="Operation">

      <t>This protocol is designed to run on port TBD, using IPv6 UDP
      unicast and link-local multicast messages to address TBD for
      transport.</t>

      <section title="Regular (trickle-driven) status update sending">

      <t>Every node is responsible for sending link-local multicast network
      state messages defined in <xref target="net-message"/> every time
      Trickle algorithm defined in <xref target="RFC6206"/> indicates
      they should on every link the protocol is active on.</t>

      <t>Trickle algorithm has 3 parameters; Imin, Imax and k. Imin and
      Imax represent minimum and maximum time intervals during which at
      least k Trickle update must be seen on a link. This specification
      does NOT mandate any defaults, but given the timer reset on data
      updates, k=1 SHOULD be used (as later retransmissions should handle
      packet loss in any case). Imax MUST be at least a minute. Imin MUST
      be at least 500 milliseconds to make this at least as
      network-unfriendly as Multicast DNS (earliest transmissions may occur
      at Imin/2 = 250 milliseconds given minimum values).</t>

      </section>

      <section title="Received packet handling">
        <t>
          <list style="numbers">

            <t>If it's multicast message:
            <list style="numbers">

              <t>Verify it's network state message defined in <xref
              target="net-message"/>, and treat Trickle state as consistent if
              and only if the network state hash matches local known state (If
              so, no need to proceed further). If not, treat Trickle state as
              inconsistent. </t>

              <t>If the message was in short format (no node state TLV(s)),
              send network state request defined in <xref
              target="req-net-message"/>.</t>

              <t>Otherwise send node state request defined in 
              <xref target="req-node-message"/> 
              for any nodes our information is outdated for (or missing). Note
              that if our information is more recent than the neighbor's, this
              may require sending nothing at all.
              </t>
            </list>
            </t>

            <t>If it's unicast message:
            <list style="numbers">

              <t>If it's request (either network state request defined in 
              <xref target="req-net-message"/> 
              , or node state request defined in 
              <xref target="req-node-message"/> 
              ), provide the required data in a reply.
              </t>

              <t>If it's reply which contains node states that seem more
              recent than ours, send node state request defined in 
              <xref target="req-node-message"/> 
              for any nodes our information is outdated for (or missing).
              If it contains node data which is more recent than
              what we have, update our state and reset Trickle
              </t>

            </list>
            </t>
            
          </list>
        </t>
      </section>

      <section title="Data updates">

        <t>Each node is responsible for publishing only a valid set of data
        in TLVs. Whenever data node publishes changes, the update number
        should be incremented. If data for own node id is detected (via
        uni- or multicast message containing node state TLVs described in
        <xref target="node-state" />) with higher update # than current,
        own update number should be made higher and data republished. </t>

        <t>Regardless of how the node data for ANY node node has changes,
        any change should reset the Trickle timer.</t>
      </section>

      <section title="Removal of whole nodes">

        <t>Whenever trickle is in inconsistent state, nodes SHOULD do
        traversal of neighbor graph (by following the neighbor TLVs under
        link TLVs of node TLVs to other node TLVs), and 
        purge all node data for nodes which are no longer reachable. </t>
      </section>
      
      <section title="Neighbor state maintenance">
        <t>Whenever unicast reply is received on a link from another node,
        the node should be added as neighbor TLV to that link TLV for
        current node. If nothing (no RAs, no HCP traffic) is received from
        that neighbor in XXX seconds, at least 3 attempts to ping it with
        request network state message defined in <xref
        target="req-net-message" /> SHOULD be sent with increasing timeouts
        (e.g. 1, 2, 4 seconds). If even after suitable period after the
        last message nothing is received, the neighbor TLV MUST be removed
        so that there are no dangling neighbors. </t>
      </section>

    </section>

    <section title="Messages">

        <t>Every message is encoded as a sequence of TLV
        objects described in <xref target="tlvs"/>. Therefore the message
        definition here defines just the set of TLVs expected in the
        particular message. 
        </t>
        
        <t>Note that in _every_ encoding scope (either root level within
        the message itself, or within container TLV), TLVs MUST be in
        ascending order based on binary comparison of both TLV header and
        value.</t>

      <section title="Network state message ((link-local) multicast)"
               anchor="net-message">
        <t>Must be present:
        <list>
          <t>node id TLV (defined in <xref target="node-id"/>).</t>
          <t>network state hash TLV (defined in <xref target="net-hash"/>).</t>
        </list>
        </t>

        <t>There may be also _all_ node state TLV(s) (defined in <xref
        target="node-state"/>), if and only if inserting all of them within
        the message would not exceed the minimum IPv6 MTU.</t>

        <t>May be present: certificate-related TLVs and signature
        TLV.</t>
      </section>

      <section title="Request network state message (unicast)"
               anchor="req-net-message">
        <t>Must be present:
        <list>
          <t>node id TLV (defined in <xref target="node-id"/>).</t>
          <t>request network state hash TLV (defined in <xref target="req-net-hash"/>).</t>
        </list>
        </t>

        <t>May be present: certificate-related TLVs and signature
        TLV.</t>

      </section>
      <section title="Request node(s) data message (unicast)"
               anchor="req-node-message">

        <t>Must be present:
        <list>
          <t>node id TLV  (defined in <xref target="node-id"/>).</t>
          <t>one or more request node data TLVs (defined in <xref
          target="req-node-data" />)).</t>
        </list>
        </t>

        <t>May be present: certificate-related TLVs and signature
        TLV.</t>

      </section>
      <section title="Reply state message (unicast)"
               anchor="reply-message">
        <t>Must be present:
        <list>
          <t>node id TLV  (defined in <xref target="node-id"/>).</t>

          <t>network state hash TLV (defined in <xref
          target="net-hash" />) and variable number of node state
          TLVs (defined in <xref target="node-state" />), or</t>

          <t>one or more node data TLVs (defined in <xref
          target="node-data" />).</t>

        </list>
        </t>

        <t>May be present: certificate-related TLVs and signature
        TLV.</t>


      </section>
    </section>

    <section anchor="tlvs" title="Type-Length-Value objects">
      <t>
        Every TLV is encoded as 2 octet type, followed by 2 octet length
        (of the value field; zero means no value whatsoever), and then
        followed by the value itself.
      </t>

      <figure>
        <artwork>
      0                   1                   2                   3
      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |            Type               |           Length              |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                             Value                             |
      |                     (variable # of bytes)                     |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
                                 TLV format
        </artwork>
      </figure>

      <t>Notation:
      <list>
        <t>.. = binary concatenation operation</t>
        <t>H(x) = hash function (TBD) of x</t>
      </list>
      </t>


      <section anchor="req-net-hash" title="Request network state hash TLV">

        <t>TLV with T=1, empty V.</t>

      </section>
      <section anchor="net-hash" title="Network state hash TLV">

        <t>TLV with T=2, V=H(value of node state hash TLV 1 .. 
        value of node state hash TLV N).</t>
        
        <t>The node states are ordered according to normal ordering rules,
        that is, in ascending order, for hashing. </t>

      </section>
      <section anchor="node-id" title="Node id TLV">

        <t>TLV with T=3, V=H(node public key) .. link id (4 octets)</t>

      </section>
      <section anchor="node-state" title="Node state TLV">

        <t>TLV with T=4, V=H(node public key) .. update # (4 octets) .. H(node data TLV)</t>

      </section>
      <section anchor="req-node-data" title="Request node data TLV">

        <t>TLV with T=5, V=H(node public key).</t>

      </section>
      <section anchor="node-data" title="Node data TLV">

        <t>TLV with T=6, V=update # (4 octets) .. a set of sub-TLVs.</t>
        <t>Notably, for any link with any hcp traffic on it, link TLV
        (described next) should be included. </t>
      </section>


      <section anchor="link-tlv" title="Link TLV">
        <t>TLV with T=7, V=link id(4 octets) .. a set of sub-TLVs</t>
        <t>Notably, for any link with neighbors detected on it, neighbor
        TLV (described next) for every neighbor should be included. </t>
        
      </section>

      <section anchor="neighbor-tlv" title="Neighbor TLV">
        <t>TLV with T=8, V=H(neighbor public key) .. neighbor link id (4 octets)</t>
        <t>This TLV indicates that the node in question vouches that the
        specified neighbor is reachable by it on the link under which the
        neighbor TLV is published. </t>
      </section>

      <section anchor="user-tlv" title="Custom URI typed TLV">
        <t>TLV with T=9, V=Null-terminated URI followed by opaque data</t>
        <t>This TLV can be used to contain anything; the URI used should be
        under control of the author of that specification. 
        For example:
        
        V='http://fingon.iki.fi/json-for-hcp' .. null .. '{"cool": "json extension!"}'
        </t>
      </section>


      <section title="Certificate-related TLVs">

        <t>TBD; should be probably some sort of certificate ID to be used
        in a lookup at most, as raw certificates will overflow easily IPv6
        minimum MTU.</t>

      </section>
      <section title="Signature TLV">

        <t>TLV with T=0xFFFF, V=(TBD) public key algorithm based signature
        of all TLVs within current scope (key used = private key matching
        the public key of the node matching the node id TLV within the
        scope).</t>

      </section>
    </section>


    <section title="Security Considerations">

      <t>If no certificate authority is used, and/or signatures are not
      employed or verified, the protocol is wide open to a variety of
      attacks. On the other hand, given security, care must be taken in
      rate limiting verification of invalid packets, as otherwise denial of
      service may occur due to exhaustion of computation resources on a
      router. </t>

    </section>

    <section anchor="iana" title="IANA Considerations">
      
      <t>TBD (IANA should maintain registry of types)</t>

    </section>

  </middle>
  <back>
    <references title="Normative references">
      <?rfc include="reference.RFC.6206.xml"?>
    </references>
    <references title="Informative references">
      <?rfc include="reference.I-D.draft-troan-homenet-sadr-01.xml"?>
      <?rfc include="reference.I-D.draft-arkko-homenet-prefix-assignment-04.xml"?>
      <?rfc include="reference.I-D.draft-stenberg-homenet-dnssdext-hybrid-proxy-ospf-00.xml"?>
    </references>
    <section title="Q &amp; A">
      <t>Q: Why not use TCP?</t>
      <t>A: It doesn't address the discovery problem. It also leads to N^2
      connections when N nodes share a link, which is awkward. </t>


      <t>Q: Why effectively build a link state routing protocol without
      routing?</t>
      <t>A: It felt like a good idea at the time. It does not require
      periodic flooding except for very minimal Trickle-based per-link
      state maintenance (potentially also neighbor reachability checks if
      so desired).</t>

      <t>Q: Why not multicast-only?</t>
      <t>A: It would require defining application level fragmentation
      scheme. Hopefully the data amounts used will stay small so we just
      trust unicast UDP to handle 'big enough' packets to contain single
      node's TLV data.</t>

    </section>
    <section title="Draft source">
      <t>As usual, this draft is available at <eref
      target="https://github.com/fingon/ietf-drafts/">https://github.com/fingon/ietf-drafts/</eref>
      in source format (with nice Makefile too). Feel free to send comments
      and/or pull requests if and when you have changes to it! </t>
    </section>

  </back>
</rfc>
