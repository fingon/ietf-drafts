<?xml version='1.0' ?>
<!--
Created:       Mon Nov 18 17:55:22 2013 mstenber
Last modified: Tue Feb  4 01:20:59 2014 mstenber
Edit time:     521 min
-->

<!DOCTYPE rfc SYSTEM 'rfc2629.dtd'>

<?rfc autobreaks="yes"?>
<?rfc compact="yes"?>
<?rfc strict='yes'?>
<?rfc subcompact="no"?>
<?rfc symrefs="yes"?>
<?rfc toc="yes"?>
<?rfc tocindent="yes"?>

<rfc
    ipr='trust200902'
    docName='draft-stenberg-homenet-hncp-00'
    category='std'
    >
  <front>
    <title abbrev="Home Networking Control Protocol">
      Home Networking Control Protocol
    </title>
    <author initials="M" surname="Stenberg" fullname="Markus Stenberg">
      <address>
        <postal>
          <street/>
          <city>Helsinki</city>
          <code>00930</code>
          <country>Finland</country>
        </postal>
        <email>markus.stenberg@iki.fi</email>
      </address>
    </author>
    <author initials="S" surname="Barth" fullname="Steven Barth">
      <address>
        <postal>
          <street/>
          <city></city>
          <code></code>
          <country></country>
        </postal>
        <email>stbarth@cisco.com</email>
      </address>
    </author>
    <date month="January" year="2014" />

    <!--    <workgroup></workgroup> -->

    <keyword>IPv6</keyword>
    <keyword>Homenet</keyword>
    <abstract>

      <t>This document describes HNCP, a minimalist state synchronization
      protocol for a homenet (or other small site). </t>

    </abstract>
  </front>
  <middle>
    <section title="Introduction">

      <t>This document describes HNCP, a protocol designed to synchronize
      state across a Home Network (Homenet) in order to facilitate
      automated configuration within the site, integration with trusted
      bootstrapping <xref target="I-D.behringer-homenet-trust-bootstrap"
      /> and default perimeter detection <xref
      target="I-D.kline-homenet-default-perimeter" />, automatic IP prefix
      distribution <xref target="I-D.pfister-homenet-prefix-assignment"
      />, and service discovery across multiple links within the homenet
      as defined in <xref
      target="I-D.stenberg-homenet-dnssd-hybrid-proxy-network-zeroconf"
      />. </t>
      
      <t>HCNP is designed to provide enough information for
      a routing protocol to operate independently without homenet-specific
      extensions. In homenet environments where multiple IPv6 prefixes are
      present, routing based on source and destination address is
      necessary <xref target="I-D.troan-homenet-sadr"/>. Routing protocol
      requirements for source and destination routing are described in
      section 3 of <xref
      target="I-D.baker-rtgwg-src-dst-routing-use-cases" />. </t>
      
    </section>

    <section title="Data model">

      <t>The data model of the HNCP protocol is simple: Every participating node
      has (and also knows for every other participating node):
      <list>
        <t>A unique node identifier. It may be a public key, unique hardware ID, or
        some other unique blob of binary data which HCNP can run a hash upon to obtain
        a node identifer that is very likely unique among the set of routers
        in the Homenet.</t>

        <t>A set of Type-Length-Value (TLV) data it wants to share with other
        routers. The set of TLVs have a well-defined order based on ascending 
        binary content that is used to quickly identify changes in the set as they
        occur relative to the set in other routers. </t>

        <t>Latest update sequence number. A four octet number that is incremented
        anytime TLV data changes are detected.</t>

        <t>Relative time, in milliseconds, since last publishing of the current TLV data set. </t>

      </list>
      </t>
      
      <t>If HNCP security is enabled, each node will have a public/private key
      pair defined. The public key is used to encrypt and/or create signatures for messages and
      node state updates. The private key is used to decrypt and/or verify signatures of
      messages and node state updates and never sent across the network by HNCP.</t>
      
    </section>

    <section title="Operation">

      <t>The protocol is designed to run on UDP port IANA-UDP-PORT, using
      both link-local scoped IPv6 unicast and link-local scoped IPv6
      multicast messages to address IANA-MULTICAST-ADDRESS for
      transport. The protocol consists of Trickle-driven multicast status
      messages, and unicast based neighbor state synchronization
      exchanges. </t>

      <section title="Regular Trickle-driven status updates">

        <t>Every node is responsible for sending link-local multicast network
        state messages defined in <xref target="net-message"/> every time
        Trickle algorithm defined in <xref target="RFC6206"/> indicates
        they should on every link the protocol is active on. Separate
        Trickle state MUST be maintained for each link.</t>

        <t>Trickle algorithm has 3 parameters; Imin, Imax and k. Imin and
        Imax represent minimum and maximum values for I, time interval
        during which at least k Trickle update must be seen on a link to
        prevent local state transmission. This specification does NOT
        mandate any defaults, but given the timer reset on data updates,
        k=1 SHOULD be used (as later retransmissions should handle packet
        loss in any case). Imax MUST be at least a minute. Imin MUST be at
        least 200 milliseconds (earliest transmissions may occur at Imin/2
        = 100 milliseconds given minimum values).</t>

        <t>When locally stored network state hash changes (either by local
        node TLV state change, or by receiving of more recent data from
        other nodes), all Trickle instances MUST be reset.</t>

      </section>

      <section title="Handling of received packets" anchor="reception">
        <t>
          While Trickle should take care of sending of periodic status
          updates for most part (see caveats in <xref target="neighbor"
          />), the unicast and multicast packet reception should work as
        follows:</t>

        <t>

          <list style="numbers">

            <t>If it is a multicast message:
            <list style="numbers">

              <t>Verify it is a network state message defined in <xref
              target="net-message"/>. If the network state hash within the
              message matches hash of locally stored network state,
              consider Trickle state as consistent. In that case, there is
              no need to proceed further. If the hashes do not match,
              consider Trickle state as inconsistent and proceed to the
              next steps. </t>

              <t>If the message was in short format (that is, it contained
              no node state TLVs), send a network state request defined in
              <xref target="req-net-message"/> using IPv6 unicast to the
              sender of the multicast message.</t>

              <t>If the message was in long format (it contained one or
              more node state TLVs), send node state request defined in
              <xref target="req-node-message"/> 
              for any nodes for which our information is outdated (our
              update number is lower than that within the message) or
              missing using IPv6 unicast to the sender of the multicast
              message. Note that if our information is more recent than
              that of the neighbor, this may require sending nothing at
              all.
              </t>
            </list>
            </t>

            <t>If it is an unicast message:
            <list style="numbers">

              <t>If it is a request (either network state request defined in 
              <xref target="req-net-message"/> 
              , or node state request defined in 
              <xref target="req-node-message"/> 
              ), provide the required data in an unicast reply.
              </t>

              <t>If it is a reply which contains node state TLVs that seem
              more recent than ours for that node (higher update number or
              we lack the node data altogether), send node state request
              defined in
              <xref target="req-node-message"/> 
              for the node data for the corresponding nodes.
              </t>

              <t>If it is a reply which contains node data TLV which is
              more recent than what we have for the corresponding node,
              update our state and reset Trickle.
              </t>

            </list>
            </t>
            
          </list>
        </t>
      </section>

      <section title="Data updates">

        <t>Each node is responsible for publishing only a valid set of data
        in TLVs contained within it's own node data TLV. Whenever the node
        data TLV's content changes, the update number should be
        incremented.</t>


        <t>If a message containing node state TLV described in <xref
        target="node-state" /> is received via unicast or multicast with
        node's own node identifier and higher update number than current,
        or same update number and different hash, there is a problem in the
        network. There are two different ways to handle this: the default
        way to handle it is to make own update number higher than the
        received one and republish node data using the same node
        identifier. If this happens more than ID-CONFLICT-COUNT times in
        ID-CONFLICT-INTERVAL seconds AND the local node identifier
        is not globally unique, new node identifier should be generated and
        node data republished with the new node identifier. (This problem
        is relevant only if not using signatures; collision of node
        identifier hashes for public keys is not considered here due to low
        likelihood of it.)</t>

        <t>Regardless of how the node data for ANY node which node has
        changes, all Trickle instances MUST be considered inconsistent
        (I=Imin + timer reset).</t>
      </section>

      <section title="Removal of whole nodes">

        <t>Whenever set of node data has changed, nodes SHOULD do traversal
        of neighbor graph (by following the neighbor TLVs defined in <xref
        target="neighbor-tlv" /> from node to node), and after traversing
        the reachable graph, purge the nodes that weren't traversed as they
        are no longer reachable. </t>

      </section>
      
      <section title="Neighbor state maintenance" anchor="neighbor">

        <t>Whenever multicast message or unicast reply is received on a
        link from another node, the node should be added as neighbor TLV
        for current node. If nothing (for example - no router
        advertisements, no HNCP traffic) is received from that neighbor in
        UNREACHABLE-TIME seconds and the neighbor is not in neighbor
        discovery cache, at least REACH-ATTEMPTS attempts to ping it with
        request network state message defined in <xref
        target="req-net-message" /> SHOULD be sent with increasing timeouts
        (e.g. 1, 2, 4 seconds). If even after suitable period after the
        last message nothing is received, the neighbor TLV MUST be removed
        so that there are no dangling neighbors. As an alternative, if
        there is a layer 2 unreachability notification of some sort
        available for either whole link or for individual neighbor, it
        MAY be used to immediately trigger removal of corresponding
        neighbor TLV(s).</t>
      </section>

    </section>

    <section title="Messages">

      <t>Every message is encoded as a sequence of TLV
      objects described in <xref target="tlvs"/>. Therefore the message
      definition here defines just the set of TLVs expected in the
      particular message. 
      </t>
      
      <t>Note that in _every_ encoding scope (either root level within
      the message itself, or within container TLV), TLVs MUST be in
      ascending order based on binary comparison of both TLV header and
      value.</t>

      <section title="Network state message ((link-local) multicast)"
               anchor="net-message">
        <t>MUST be present:
        <list>
          <t>node link TLV (defined in <xref target="node-id"/>).</t>
          <t>network state TLV (defined in <xref target="net-hash"/>).</t>
        </list>
        </t>

        <t>There SHOULD be also _all_ node state TLV(s) (defined in <xref
        target="node-state"/>), if and only if inserting all of them within
        the message would not exceed the minimum IPv6 MTU. Sending of just
        some node state TLV(s) MUST NOT be done as it would confuse the
        packet reception algorithm described in <xref
        target="reception"/>. </t>

        <t>MAY be present: authentication TLVs (see <xref target="auth-tlvs" />).</t>

      </section>

      <section title="Request network state message (unicast)"
               anchor="req-net-message">
        <t>MUST be present:
        <list>
          <t>node link TLV (defined in <xref target="node-id"/>).</t>
          <t>request network state TLV (defined in <xref target="req-net-hash"/>).</t>
        </list>
        </t>

        <t>MAY be present: authentication TLVs (see <xref target="auth-tlvs" />).</t>

      </section>
      <section title="Request node(s) data message (unicast)"
               anchor="req-node-message">

        <t>MUST be present:
        <list>
          <t>node link TLV  (defined in <xref target="node-id"/>).</t>
          <t>one or more request node data TLVs (defined in <xref
          target="req-node-data" />)).</t>
        </list>
        </t>

        <t>MAY be present: authentication TLVs (see <xref target="auth-tlvs" />).</t>

      </section>
      <section title="Reply state message (unicast)"
               anchor="reply-message">
        <t>MUST be present:
        <list>
          <t>node link TLV  (defined in <xref target="node-id"/>).</t>

          <t>network state TLV (defined in <xref target="net-hash" />)
          and node state TLV (defined in <xref target="node-state" />) for
          every known node by the sender, or</t>

          <t>one or more combinations of node state and node data TLVs
          (defined in <xref target="node-data" />).</t>

        </list>
        </t>

        <t>MAY be present: authentication TLVs (see <xref target="auth-tlvs" />).</t>


      </section>
    </section>

    <section anchor="tlvs" title="Type-Length-Value objects">
      <t>
        Every TLV is encoded as 2 octet type, followed by 2 octet length
        (of the whole TLV, including header; 4 means no value whatsoever),
        and then the value itself (if any).

        The actual length of TLV MUST be always divisible by 4; if the
        length of the value is not, zeroed padding bytes MUST be inserted
        at the end of TLV. The padding bytes MUST NOT be included in the
        length field.
      </t>

      <figure>
        <artwork>
          0                   1                   2                   3
          0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
          +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
          |            Type               |           Length              |
          +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
          |                             Value                             |
          |                     (variable # of bytes)                     |
          +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
          TLV format
        </artwork>
      </figure>

      <t>
        Encoding of type=123 (0x7b) TLV with value 'x' (120 = 0x78):

        007B 0005 7800 0000
      </t>

      <t>Notation:
      <list>
        <t>.. = octet string concatenation operation</t>
        <t>H(x) = MD5 hash of x</t>
        <t>H-64(x) = H(x) truncated by taking just first 64 bits of the result.</t>
      </list>
      </t>


      <section title="Request TLVs (for use within unicast requests)">

        <section anchor="req-net-hash" title="Request network state TLV">

          <t>TLV with T=2, empty V.</t>

        </section>
        <section anchor="req-node-data" title="Request node data TLV">

          <t>TLV with T=3, V=H(node identifier).</t>

        </section>

      </section>
      <section title="Data TLVs (for use in both multi- and unicast data)">
        <section anchor="node-id" title="Node link TLV">

          <t>TLV with T=1, V=H(node identifier) .. link id (4 octets)</t>

        </section>
        <section anchor="net-hash" title="Network state TLV">

          <t>TLV with T=4, V=H(H(node data TLV 1) .. H(node data TLV N)).</t>
          
          <t>The node data are ordered for hashing by octet comparison of
          the corresponding node identifier hashes in ascending order.</t>

        </section>
        <section anchor="node-state" title="Node state TLV">

          <t>TLV with T=5, V=H(node identifier) .. update # (4 octets)
          .. milliseconds since origination (4 octets) .. H(node data TLV)</t>

          <t>Whole network should have roughly same idea about the time
          since origination; even the originating router should increment
          the time whenever it needs to send new node state TLV regarding
          itself without changing the corresponding node data TLV. It is
          not included within node data TLV, however, as that is immutable
          and potentially signed by the originating node at the time of
          origination.</t>

        </section>
        <section anchor="node-data" title="Node data TLV">

          <t>TLV with T=6, V=H(node identifier) .. update # (4 octets) .. a
          set of sub-TLVs.</t>

          <t>Public key TLV (described in <xref target="node-pk-tlv" />
          SHOULD be always included if signatures are ever used. </t>
          <t>If signatures in use, the node data TLV SHOULD also contain
          originator's own signature TLV. </t>
        </section>


        <section anchor="node-pk-tlv" title="Node public key TLV (within
                                             node data TLV)">
          <t>TLV with T=7, V=public key (=raw node identifier)</t>

          <t>Public key data for the node. Only relevant if signatures are
          used. Can be used to verify that H(node identifier) equals public
          key, and that the signature TLV within node data matches public
          key. </t>

        </section>

        <section anchor="neighbor-tlv" title="Neighbor TLV (within node data TLV)">
          <t>TLV with T=8, V=H(neighbor node identifier)  .. neighbor link id (4 octets).. local link id (4 octets)</t>
          <t>This TLV indicates that the node in question vouches that the
          specified neighbor is reachable by it on the local link id
          given. This reachability may be unidirectional (if no unicast
          exchanges have been performed with the neighbor). The TLV at least 
          guarantees that the node publishing the TLV has received traffic
          from the neighbor recently. For guaranteed bidirectional
          reachability, existence of both nodes' matching neighbor TLVs
          should be checked. </t>
        </section>

      </section>

      <section anchor="user-tlv" title="Custom TLV (within/without node data TLV)">
        <t>TLV with T=9, V=H-64(URI) .. opaque data</t>
        <t>This TLV can be used to contain anything; the URI used should be
        under control of the author of that specification. 
        For example:</t>
        
        <t>V=H-64('http://example.com/author/json-for-hncp') .. '{"cool": "json
        extension!"}'</t>

        <t>or</t>

        <t>V=H-64('mailto:author@example.com') .. '{"cool": "json
        extension!"}'</t>

      </section>

      <section title="Authentication TLVs" anchor="auth-tlvs">

        <section title="Certificate-related TLVs">

          <t>TBD; should be probably some sort of certificate ID to be used
          in a lookup at most, as raw certificates will overflow easily IPv6
          minimum MTU.</t>

        </section>
        <section title="Signature TLV">

          <t>TLV with T=0xFFFF, V=(TBD) public key algorithm based
          signature of all TLVs within current scope as well as the parent
          TLV header, if any. The assumed signature key is private key
          matching the public key of the the originator of node link TLV
          (if signature TLV is within main body of message), or that of the
          originator of the node data TLV (if signature TLV is within node
          data TLV)..</t>

        </section>
      </section>
    </section>


    <section title="Border Discovery and Prefix Assignment">

      <t>Automatic discovery of perimeter borders is desirable - where
      possible - to ease the configuration of the homenet.  HNCP utilizes the
      <xref target="I-D.kline-homenet-default-perimeter">Default Border
      Definition</xref> and extends it with a border discovery algorithm
      derived from the edge router interactions
      described in the <xref target="RFC7084">Basic Requirements for IPv6
      Customer Edge Routers</xref></t>
      
      <t>An interface MUST be considered external if at least one of the
      following conditions is satisfied:

      <list style="numbers">
	<t>The interface has a fixed category classifying it as external.</t>

	<t>A delegated prefix could be acquired by running a DHCPv6-client
	on the interface.</t>

	<t>An IPv4-address could be acquired by running a DHCP-client on
        the interface.</t>

	<t>HNCP authentication is enabled and there are routers on the
        interface which could not be authenticated.</t>

      </list>
      </t>
      
      <t>Each router MUST continuously scan each active interface that does
      not have a fixed category in order to dynamically reclassify it if
      necessary.  The router therefore runs an appropriately configured
      DHCP and DHCPv6-client as long as the interface is active including
      states where it considers the interface to be internal. The router
      SHOULD wait for a period of TBD seconds before treating a newly
      activated or previously external interface as internal. Once it
      treats a certain interface as internal it MUST start forwarding
      traffic with appropriate source addresses between its internal
      interfaces and allow internal traffic to reach external networks.
      Once a router detects an interface to be external it MUST stop any
      previously enabled internal forwarding. In addition it SHOULD
      announce the acquired information for use in the homenet as described
      in later sections of this draft if the interface appears to be
      connected to an external network.</t>
      
      <t>In order to avoid conflicts between border discovery and homenet
      routers running DHCP-servers each router MUST implement the following
      mechanism based on <xref target="RFC3004">The User Class Option for
      DHCP</xref> into its DHCP-logic:

      <list>

	<t>A homenet router running a DHCP-client on a homenet-interface
	MUST include a DHCP User-Class consisting of the ASCII-String
	"HOMENET".</t>

	<t>A homenet router running a DHCP-server on a homenet-interface
        MUST ignore DHCP-Requests containing a DHCP User-Class consisting
        of the ASCII-String "HOMENET".</t>

      </list>
      </t>

      <t>To distribute an external connection in the homenet an edge router
      announces one or more delegated prefixes and associated
      DHCP(v6)-encoded auxiliary information like recursive
      DNS-servers. Each external connection is announced using one
      container-TLV as follows:</t>
      
      <figure>
	<artwork>
          0                   1                   2                   3
          0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
          +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
          | Type: EXTERNAL-CONNECTION (41)|          Length: > 4          |
          +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
          |                          Nested TLVs                          |
	</artwork>
      </figure>
      
      
      <t>Auxiliary connectivity information is encoded as a stream of
      DHCPv6-attributes or DHCP-attributes placed inside a TLV of type
      EXTERNAL-CONNECTION or DELEGATED-PREFIX (for IPv6 prefix-specific
      information).  There MUST NOT be more than one instance of this TLV
      inside a container and the order of the DHCP(v6)-attributes contained
      within it MUST be preserved as long as the information contained does
      not change. The TLVs are encoded as follows:</t>
      
      <figure>
	<artwork>
          0                   1                   2                   3
          0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
          +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
          |    Type: DHCPV6-DATA (45)     |          Length: > 4          |
          +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
          |                    DHCPv6 attribute stream                    |
	</artwork>
      </figure>

      <t>and</t>

      <figure>
	<artwork>
          0                   1                   2                   3
          0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
          +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
          |     Type: DHCP-DATA (44)      |          Length: > 4          |
          +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
          |                      DHCP attribute stream                    |
	</artwork>
      </figure>
      
      
      <t>Each delegated prefix is encoded using one TLV inside an
      EXTERNAL-CONNECTION TLV. For external IPv4 connections the prefix is
      encoded in the form of an IPv4-mapped address and is usually from a
      <xref target="RFC1597">private address range</xref>. The related TLV
      is defined as follows.</t>
      
      <figure>
	<artwork>
          0                   1                   2                   3
          0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
          +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
          |  Type: DELEGATED-PREFIX (42)  |         Length: >= 13         |
          +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
          |                   Valid until (milliseconds)                  |
          +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
          |                 Preferred until (milliseconds)                |
          +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
          | Prefix Length |                                               |
          +-+-+-+-+-+-+-+-+        Prefix Address [+ nested TLVs]         +
          |                                                               |
	</artwork>
      </figure>
      
      <t>
	<list>
	  <t>Valid until is the time in milliseconds the delegated prefix
          is valid. The value is relative to the point in time the TLV is
          first announced.</t>

	  <t>Preferred until is the time in milliseconds the delegated
          prefix is preferred. The value is relative to the point in time
          the TLV is first announced.</t>

	  <t>Prefix length specifies the number of significant bits in the
          prefix.</t>

	  <t>Prefix address is of variable length and contains the
	  significant bits of the prefix padded with zeroes up to the next
	  byte boundary.</t>

	  <t>Nested TLVs might contain prefix-specific information like
          DHCPv6-options.</t>

	</list>
      </t>

      <t>In order for routers to use the distributed information, prefixes
      and addresses have to be assigned to the interior links of the
      homenet.  A router MUST therefore implement the algorithm defined in
      <xref target="I-D.pfister-homenet-prefix-assignment">Prefix and
      Address Assignment in a Home Network</xref>.  In order to announce
      the assigned prefixes the following TLVs are defined.</t>
      
      <t>Each assigned prefix is given to an interior link and is encoded
      using one TLVs.  Assigned IPv4 prefixes are stored as mapped
      IPv4-addresses. The TLV is defined as follows:</t>

      <figure>
	<artwork>
          0                   1                   2                   3
          0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
          +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
          |  Type: ASSIGNED-PREFIX (43)   |          Length: >= 9         |
          +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
          |                        Link Identifier                        |
          +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
          |  R. |A| Pref. | Prefix Length |                               |
          +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+         Prefix Address        +
          |                                                               |
	</artwork>
      </figure>
      <t>
	<list>
	  <t>Link Identifier is the local HNCP identifier of the link the
          prefix is assigned to.</t>

	  <t>R. is reserved for future additions and must be set to 0 when
          creating TLVs and ignored when parsing them.</t>

	  <t>A is the authoritative flag which indicates that an assigment
          is enforced and ignores usual collision detection rules.</t>

	  <t>Pref. describes the preference of the assignment and can be
          used to differentiate the importance of a given assignment over
          others.</t>

	  <t>Prefix length specifies the number of significant bits in the
          prefix.</t>

	  <t>Prefix address is of variable length and contains the
	  significant bits of the prefix padded with zeroes up to the next
	  byte boundary.</t>
	</list>
      </t>
      
      <t>In some cases (e.g. IPv4) the set of addresses is very limited
      and stateless mechanisms are not really suitable for address assignment.
      Therefore HNCP can manage router address in these cases by itself.  Each router
      assigning an address to one of its interfaces announces one TLV of the
      following kind:</t>

      <figure>
	<artwork>
          0                   1                   2                   3
          0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
          +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
          |   Type: ROUTER-ADDRESS (46)   |           Length: 20          |
          +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
          |                                                               |
          |                         Router Address                        |
          |                                                               |
          |                                                               |
          +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

	</artwork>
      </figure>	
      
      <t>
	<list>
	  <t>Router Address is the address assigned to one of the router interfaces.</t>
	</list>
      </t>
    </section>

    <section anchor="how" title="Service Discovery">

      <t>If service discovery support is required, it's semantics (if
      supported) MUST be implemented according to <xref
      target="I-D.stenberg-homenet-dnssd-hybrid-proxy-network-zeroconf"
      /> . For full support, support for following three different new HNCP
      TLVs is needed. However, only the DNS Delegated Zone TLV MUST be
      supported, and the other two SHOULD be supported. </t>

      <section anchor="delegated-zone-tlv" title="DNS Delegated Zone TLV">

        <figure>
          <artwork>
            0                   1                   2                   3
            0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            |      Type=50                  |           Length              |
            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            |                                                               |
            |                           Address                             |
            |                          (16 bytes)                           |
            |                                                               |
            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            |Reserved   |S|B| Zone (DNS label sequence - variable length)   |
            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            DNS Delegated Zone TLV
          </artwork>
        </figure>
      </section>

      <section anchor="domain-name-tlv" title="Domain Name TLV">

        <figure>
          <artwork>
            0                   1                   2                   3
            0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            |      Type=51                  |           Length              |
            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            |Domain (DNS label sequence - variable length)                  |
            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            Domain Name TLV
          </artwork>
        </figure>

      </section>
      <section anchor="router-name-tlv" title="Router Name TLV">
        <figure>
          <artwork>
            0                   1                   2                   3
            0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            |      Type=52                  |           Length              |
            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            |Name (not even null terminated - variable length)              |
            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            Router Name TLV
          </artwork>
        </figure>
      </section>
    </section>

    <section title="Routing support">
      <section title="Protocol Requirements">
	<t>Each routing protocol needs to meet a certain set of criteria (either natively or through extensions) in order to be usable inside a homenet. These include:
	<list>
	  <t>The routing protocol complies with the <xref target="I-D.baker-rtgwg-src-dst-routing-use-cases">Requirements and Use Cases for Source/Destination Routing</xref></t>
	  <t>The routing protocol supports and uses an autoconfiguration mechanism that allows it to operate without the need for prior individual configuration of each router.</t>
	</list>
	</t>
	<t>A router MUST NOT announce that it supports a certain routing protocol if its implementation of the routing protocol does not meet these requirements,
	e.g. it does not implement extensions that are necessary for compliance.</t>
      </section>
      
      <section title="Announcement">
	<t>Each router MUST announce any routing protocol that is supported and intended to be used in the homenet.
	It SHOULD assign a preference value for each protocol that indicates its desire to use said protocol over other protocols it supports and SHOULD
	make these values configurable.</t> 
	
	<t>Each router includes one HNCP TLV of type ROUTING-PROTOCOL for every such routing protocol. This TLV is defined as follows:</t>
	<figure>
	  <artwork>
            0                   1                   2                   3
            0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            |  Type: ROUTING-PROTOCOL (60)  |           Length: 6           |
            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            |  Protocol ID  |   Preference  |
            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
	  </artwork>
	</figure>
	<t>
	  <list>
	    <t>Protocol ID is one of:
	    <list>
	      <t>0 = reserved</t>
	      <t>1 = Babel (dual-stack)</t>
	      <t>2 = OSPFv3 (dual-stack)</t>
	      <t>3 = IS-IS (dual-stack)</t>
	      <t>4 = RIP (dual-stack)</t>
	    </list>
	    </t>
	    <t>Preference is a value from 0 to 255. If a router is neutral
	    about a routing protocol it SHOULD use the value 128,
	    otherwise a lower value indicating lower preference
	    or a higher value indicating higher preference respectively.</t>
	  </list>
	</t>
      </section>
      
      <section title="Protocol Selection">
	<t>Whenever a router joins a homenet or detects that a new router has been added to or removed from the homenet
	it MUST run the routing protocol selection algorithm.</t>
	
	<t>To select a routing protocol each router examines the announced protocols
	and respective preference values of each router in the homenet and selects the protocol that:
	<list style="numbers">
	  <t>is understood by all routers in the homenet</t>

	  <t>has the highest preference value among
          all routers (calculated as sum of preference
          values)</t>

	  <t>has the highest protocol ID among those with the
	  highest preference</t>
	</list>
	</t>
	
	<t>After selecting a new routing protocol which differs from the currently running one a router MUST stop the previously running protocol or mechanism
	and ensure that all old routes have been removed. Thereafter the router MUST start the newly selected protocol or mechanism.
	If no protocol could be selected, the router MUST stop the previously running routing protocol and instead
	run the algorithm defined in the following section in order to setup its routing table for the network.</t>
      </section>

      <section title="Fallback Mechanism">
	<t>In cases where there is no commonly understood routing protocol a fallback algorithm is run to setup routing and preserve interoperability among the homenet.
	While not intended to replace a routing protocol this mechanism provides a valid - but not necessarily ideal - routing topology.
	It solely relies on the uplink and neighbour information exchanged by HNCP itself 
	and therefore does not require any additional data exchange. The algorithm is defined as follows:
	
	<list style="numbers">
	  <t>Interpret the neighbour information received via HNCP as a graph of connected routers.</t>
	  <t>Use breadth-first traversal to determine the next-hop and hop-count in the path to each router in the homenet:
	  <list>
	    <t>Start the traversal with the immediate neighbours of the router running the algorithm.</t>
	    <t>Always visit the immediate neighbours of a router in ascending order of their router ID.</t>
	    <t>Never visit a router more often than once.</t>
	  </list>
	  </t>
	  <t>For each delegated prefix P of any router R in the homenet: Create a default route via the next-hop for R acquired in #2.
	  Each such route MUST be source-restricted to only apply to traffic with a source address within P and its metric MUST reflect the hop-count to R.</t>
	  <t>For each assigned prefix A of a router R:
	  Create a route to A via the next-hop for R acquired in #2. Each such route MUST NOT be source-restricted.</t>
	  <t>For the first router R visited in the traversal annuncing an IPv4-uplink: Create a default IPv4-route via the next-hop for R acquired in #2.</t>
	  <t>For each assigned IPv4-prefix A of a router R: Create an IPv4-route to A via the next-hop for R acquired in #2.</t>
	</list>
	</t>
      </section>

    </section>

    <section title="Security Considerations">
      <t>There are at least 3 ways in which this protocol can be deployed:

      <list>
      
      	<t>General security issues for Home Networks is discussed at length in 
      	[Homenet Arch Ref]. The protocols used to setup IP 
      	in home networks today have very little security enabled within the 
      	control protocol itself. For example, DHCP has defined RFC 3118 to authenticate 
      	DHCP messages, but this is very rarely implemented in large or small networks.  
      	Further, while PPP can provide 
      	secure authentication of both sides of a point to point link, it is most often 
      	deployed with one-way authentication of the subscriber to the ISP, not
      	the ISP to the subscriber. HNCP aims to make security as easy as possible
      	for the implementer by including built-in capabilities for encryption
      	and authentication of node data being exchanged as well as the protocol 
      	messages themselves in as lightweight and flexible a manner as possible, 
      	but it is ultimately up to the shipping system to
      	take advantage of the protocol constructs defined in this and related
      	documents.</t>
      
       	<t> HNCP is designed to integrate with trusted bootstrapping as 
	defined in <xref target="I-D.behringer-homenet-trust-bootstrap" />,
       	including the ability to digitally sign and encrypt messages
       	between routers.  This can be done in order to define a border as 
       	well as protect against malicious attacks and spoofing attempts from
       	inside or outside the border. </t>	
       
      	<t>In the absence of a shared key or public/private key pair, HNCP itself
      	sends messages as clear text which is as secure, or insecure, as the 
       	security of the link below, as discussed in <xref 
       	target="I-D.kline-homenet-default-perimeter" />. When no unique public
       	key is available, a hardware fingerprint or equivalent to identify 
       	routers must be available for use by HNCP.</t>
       	
        <t>IPsec could be used, though it requires manually keyed IPsec
        per-port granularity for port IANA-UDP-PORT UDP traffic. 
        A pre-shared key has to be utilized in this case
        as well given IKE cannot be used with multicast traffic.</t>
        
        <t>If even every router cannot be trusted, or some more guarantees
        about source of particular node status updates is desired, real
        public and private keys should be used to create signatures and 
        verify them in HNCP on both on per-node data TLVs as well as across the entire message.
        In this mode, care must be taken in rate limiting verification of invalid packets,
        as otherwise denial of service may occur due to exhaustion of
        computation resources (unless sufficient cryptographic support 
        is known to be present in the home router).
        </t>
        
      </list>
      </t>

      <t>As a performance optimization, instead of providing signatures for
      actual node data and the protocol messages themselves, it is also
      possible to provide signatures just for protocol messages. While 
      this means it is no longer possible to verify the original source of the node
      data itself, as long as the set of routers is trusted (i.e., no router
      in the set has itself been hacked to provide malicious node data) then 
      one can assume the node data is trusted because the router is trusted and
      the data arrived in a protected protocol message.</t>

    </section>

    <section anchor="const" title="Protocol constants">
      <t>Imin (for Trickle) >= 200 milliseconds</t>
      <t>Imax (for Trickle) >= 60 seconds</t>
      <t>k (for Trickle) suggested to be 1</t>

      <t>ID-CONFLICT-COUNT and ID-CONFLICT-INTERVAL are left up
      to the implementation (they are local choices)</t>

      <t>UNREACHABLE-TIME should be proportional with Imax
      (smaller values not useful; orders of magnitude larger values
      neither). Again local choice.</t>

      <t>REACH-ATTEMPTS should depend on media used, but at least
      'few', e.g. 3 times.</t>

    </section>
    
    <section anchor="iana" title="IANA Considerations">
      
      <t>IANA should set up a registry for HNCP TLV types, with following
      initial contents:</t>

      <t>0: Reserved (should not happen on wire)</t>
      <t>1: Node link</t>
      <t>2: Request network state</t>
      <t>3: Request node data</t>
      <t>4: Network state</t>
      <t>5: Node state</t>
      <t>6: Node data</t>
      <t>7: Node public key</t>
      <t>8: Neighbor</t>
      <t>9: Custom</t>
      <t>41: External connection</t>
      <t>42: Delegated prefix</t>
      <t>43: Assigned prefix</t>
      <t>44: DHCP-data</t>
      <t>45: DHCPv6-data</t>
      <t>46: Router-address</t>
      <t>50: DNS Delegated Zone</t>
      <t>51: Domain name</t>
      <t>52: Node name</t>
      <t>60: Routing protocol</t>
      <t>65535: Signature</t>

      <t>IANA should also allocate UDP port number IANA-UDP-PORT, as well as
      IPv6 link-local multicast address IANA-MULTICAST-ADDRESS for HNCP use.</t>

    </section>

  </middle>
  <back>
    <references title="Normative references">
      <?rfc include="reference.RFC.6206.xml"?>

      <reference anchor='I-D.pfister-homenet-prefix-assignment'>
        <front>
          <title>Prefix and Address Assignment in a Home Network</title>
          <author initials='P' surname='Pfister' fullname='Pierre Pfister'>
            <organization />
          </author>
          <author initials='J' surname='Arkko' fullname='J. Arkko'>
            <organization />
          </author>
          <author initials='B' surname='Paterson' fullname='B. Paterson'>
            <organization />
          </author>
          <date month='January' day='31' year='2014' />
        </front>
        <seriesInfo name='Internet-Draft' value='draft-pfister-homenet-prefix-assignment-00' />
      </reference>



      <reference anchor='I-D.stenberg-homenet-dnssd-hybrid-proxy-network-zeroconf'>
        <front>

          <title>Auto-Configuration of a Network of Hybrid
          Unicast/Multicast DNS-Based Service Discovery Proxy Nodes
          </title>

          <author initials="M" surname="Stenberg" fullname="Markus Stenberg">
            <organization />
          </author>
          <date month='January' day='31' year='2014' />
        </front>
        <seriesInfo name='Internet-Draft' value='draft-pfister-homenet-prefix-assignment-00' />
      </reference>


    </references>
    <references title="Informative references">
      <?rfc include="reference.RFC.7084.xml"?>
      <?rfc include="reference.RFC.3004.xml"?>
      <?rfc include="reference.RFC.1597.xml"?>
      <?rfc include="reference.I-D.draft-troan-homenet-sadr-01.xml"?>
      <?rfc include="reference.I-D.draft-behringer-homenet-trust-bootstrap-00.xml"?>
      <?rfc include="reference.I-D.draft-baker-rtgwg-src-dst-routing-use-cases-00.xml"?>
      <?rfc include="reference.I-D.draft-kline-homenet-default-perimeter-00.xml"?>
      <?rfc include="reference.I-D.draft-arkko-homenet-prefix-assignment-04.xml"?>
      <?rfc include="reference.I-D.draft-stenberg-homenet-dnssdext-hybrid-proxy-ospf-00.xml"?>
    </references>
    <section title="TODO">

      <t>Should we use MD5 hashes, or EUI-64 node identifier to identify
      nodes?</t>

      <t>Is there a case for non-link-local unicast? Currently explicitly
      stating this is link-local only protocol. </t>

      <t>Consider if using Trickle with k=1 really pays off, as we need to
      do reachability checks if L2 doesn't provide them periodically in any
      case. Using Trickle with k=inf would remove the need for unicast
      reachability checks, but at cost of extra multicast traffic. On the
      other hand, N*(N-1)/2 unicast reachability checks when lot of routers
      share a link is not appealing either.</t>

    </section>
    <section title="Q &amp; A">
      <t>Q: Why not use TCP?</t>

      <t>A: It doesn't address the node discovery problem. It also leads to
      N*(N-1)/2 connections when N nodes share a link, which is
      awkward. </t>

      <t>Q: Why effectively build a link state routing protocol without
      routing?</t>

      <t>A: It felt like a good idea at the time. It does not require
      periodic flooding except for very minimal Trickle-based per-link
      state maintenance (potentially also neighbor reachability checks if
      so desired).</t>

      <t>Q: Why not multicast-only?</t>

      <t>A: It would require defining application level fragmentation
      scheme. Hopefully the data amounts used will stay small so we just
      trust unicast UDP to handle 'big enough' packets to contain single
      node's TLV data. On some link layers unicast is also much more
      reliable than multicast, especially for large packets.</t>

      <t>Q: Why so long IDs? Why real hash?</t>

      <t>A: Specifying conflict detection for smaller IDs was harder, and
      scalability of protocol isn't really affected by using real
      (=cryptographic) hash function.</t>

      <t>Q: Why trust IPv6 fragmentation in unicast case? Why not do L7
      fragmentation?</t>

      <t>A: Because it will be there for a while at least. And while PMTU
      et al may be problems on open internet, in a home network
      environment UDP fragmentation should NOT be broken in the foreseeable
      future. </t>

      <t>Q: Should there be nested container syntax that is actually
      self-describing? (i.e. type flag that indicates container, no body
      except sub-TLVs?)</t>

      <t>A: Not for now, but perhaps valid design.. TBD.</t>
      
      <t>Q: Why not doing (performance thing X, Y or Z)?</t>

      <t>A: This is designed mostly to be minimal (only timers Trickle
      ones; everything triggered by Trickle-driven messages or local state
      changes). However, feel free to suggest better (even more minimal)
      design which works. </t>

    </section>
    <section title="Draft source">
      <t>As usual, this draft is available at <eref
      target="https://github.com/fingon/ietf-drafts/">https://github.com/fingon/ietf-drafts/</eref>
      in source format (with nice Makefile too). Feel free to send comments
      and/or pull requests if and when you have changes to it! </t>
    </section>

    <section title="Implementation">

      <t>A GPLv2-licensed experimental work-in-progress implementation of the protocol is
      available at <eref
      target="https://github.com/sbyx/hnetd/">https://github.com/sbyx/hnetd/</eref>. Comments
      and/or pull requests are welcome too.</t>
      
      <t>An earlier implementation of the same principles and similar algorithms on top of OSPFv3 is
      	available at <eref target="http://www.homewrt.org/doku.php?id=downloads">http://www.homewrt.org/doku.php?id=downloads</eref>.
      </t>
    </section>

    <section title="Acknowledgements">

      <t>Thanks to Ole Troan, Pierre Pfister, Mark Baugher, Mark Townsley
      and Juliusz Chroboczek for review comments.</t>

    </section>
    
  </back>
</rfc>
