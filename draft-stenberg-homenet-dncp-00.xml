<?xml version='1.0' ?>
<!--
Created:       Mon Nov 18 17:55:22 2013 mstenber

split from draft-ietf-homenet-hncp-03-pre - generic parts

TBD:
- interface <> link terminology

- include e.g. message, or TLV suffix within xref, or not?
 .. for the time being, it is included

 - sequence number overflow..
 - looping space probably best choice

 - should we actually have 4 byte length in messages on stream transport?
should be able to just detect the link id TLV :-p

- explain hash of hashes idea somewhere ~early
 - define also network state hash?

- proactive 'push' MAY/SHOULD?

- consider if node state + data should be merged like Pierre suggested

- think about short node state, ~medium long state, full long state

-->

<!DOCTYPE rfc SYSTEM 'rfc2629.dtd'>

<?rfc autobreaks="yes"?>
<?rfc compact="yes"?>
<?rfc strict='yes'?>
<?rfc subcompact="no"?>
<?rfc symrefs="yes"?>
<?rfc toc="yes"?>
<?rfc tocindent="yes"?>

<rfc
    ipr='trust200902'
    docName='draft-stenberg-homenet-dncp-00'
    category='std'
    >
  <front>
    <title abbrev="Distributed Node Consensus Protocol">
      Distributed Node Consensus Protocol
    </title>
    <author initials="M" surname="Stenberg" fullname="Markus Stenberg">
      <address>
        <postal>
          <street/>
          <city>Helsinki</city>
          <code>00930</code>
          <country>Finland</country>
        </postal>
        <email>markus.stenberg@iki.fi</email>
      </address>
    </author>
    <author initials="S" surname="Barth" fullname="Steven Barth">
      <address>
        <postal>
          <street/>
          <city></city>
          <code></code>
          <country></country>
        </postal>
        <email>cyrus@openwrt.org</email>
      </address>
    </author>
    <date month="November" year="2014" />

    <area>Internet</area>
    <workgroup>Homenet Working Group</workgroup>
    <keyword>Homenet</keyword>
    <abstract>

      <t>This document describes the Distributed Node Consensus Protocol
      (DNCP), a generic, Trickle-using state synchronization protocol. DNCP
      is transport agnostic, but some of the details are left to DNCP
      profiles, which define actual implementable versions of DNCP by
      filling in the blanks left by the this document. </t>

    </abstract>
  </front>
  <middle>
    <section title="Introduction">

      <t>DNCP is designed to provide a way for nodes to publish their local
      state, as an ordered set of TLV (Type-Length-Value) tuples, and to
      also receive state published by all other DNCP nodes that are
      reachable.</t>

      <t>DNCP has relatively few requirements for the underlying transport;
      it requires some way of transmitting either datagram or stream data
      to a DNCP peer, and if used in multicast mode, a way of sending
      multicast messages. If security is desired and one of the built-in
      security methods is to be used, definition of appropriate <xref
      target="RFC2246">TLS</xref> or <xref target="RFC6347">DTLS</xref>
      transport for the underlying transport protocol is also
      required. </t>

    </section>

    <section anchor="kwd" title='Requirements Language'>

      <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL
      NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED",  "MAY", and
      "OPTIONAL" in this document are to be interpreted as described in
      <xref target='RFC2119'>RFC 2119</xref>.</t>

    </section>

    <section title="Terminology">
      <t>
        <list style="hanging">

          <t hangText="DNCP profile"> is a protocol which uses DNCP, and
          specifies transport details and other parts of DNCP that are noted in
          <xref target="profile-bits"/>. For readability, any DNCP profile
          specific parameters with profile-specific fixed value are prefixed
          with DNCP_.</t>

          <t hangText="DNCP node"> is a single node which runs a DNCP profile
          implementing protocol.</t>

          <t hangText="DNCP network"> is a set of DNCP nodes running the same
          DNCP profile that can reach each other, either via learned shared
          connections in the underlying network, or by knowing address of each
          other.</t>

          <t hangText="(DNCP) peer"> refers to another DNCP node with which
          a DNCP node communicates directly.</t>

          <t hangText="Node identifier"> is an opaque, fixed-length identifier of
          DNCP_NODE_IDENTIFIER_LENGTH_BYTES which uniquely identifies a DNCP
          node in a DNCP network. </t>

          <t hangText="Link"> represents either an actual interface on a node,
          or virtual one with fixed end-point address that may or may not have
          running DNCP node.</t>

          <t hangText="Link identifier"> is a 32-bit opaque value, which
          identifies uniquely particular link for that particular DNCP
          node.</t>

	  <t hangText="Effective verdict"> for any certificate is defined
	  as the one with the highest priority from all verdicts announced
	  for said certificate at the time in the DNCP network.</t>

        </list>
      </t>

    </section>

    <section title="Data Model">

      <t>Every DNCP node in the DNCP network has, and also knows for every
      other DNCP node:
      <list style="symbols">

        <t>Node identifier.</t>

        <t>An ordered set of TLV tuples it wants to share with other nodes
        possibly far off. The set of TLVs have a well-defined order based
        on ascending binary content (including TLV type and length). This
        facilitates linear time state delta processing. </t>

        <t>Latest update sequence number, a 32 bit number that is
        incremented any time the TLV set is published.</t>

        <t>Relative time, in milliseconds, since last publishing of the
        current TLV data set with the current update sequence number. It is
        also 32 bit number on the wire.  If this number is close to
        overflow (>= 2^32-2^16), a node MUST re-publish it's TLVs even if
        there is no change to avoid overflow of the value.</t>

      </list>
      </t>

      <t>Additionally, every DNCP node has a set of links for which
      DNCP is configured to be used. For each such link, a node should
      have:

      <list style="symbols">
        <t>Link identifier.</t>

        <t>Local interface, or an address of a DNCP peer it is connected
        to.</t>

        <t><xref target="RFC6206">Trickle</xref> instance with parameters
        I, T, and c.</t>
      </list>
      </t>

      <t>For each DNCP peer detected on a link, a node has:
      <list style="symbols">

        <t>Link identifier of the DNCP peer.</t>

        <t>Timestamp which indicates the last time something was received
        from the DNCP peer.</t>

        <t>Most recent address used by the DNCP peer (in an authenticated
        message, if security is enabled).</t>

      </list>
      </t>

    </section>

    <section title="Operation">

      <t>DNCP protocol consists of <xref target="RFC6206">Trickle</xref>
      driven unicast or multicast status messages which indicate current
      status of shared TLV data, and additional unicast message exchanges
      which ensure DNCP peer reachability and synchronize the data when
      necessary. </t>

      <t>If DNCP is to be used on an actual interface, as opposed to only
      point-to-point using known remote address(es), datagram-based
      transport which supports multicast SHOULD be defined in DNCP profile
      to be used for the messages to be sent to the whole link. As this is
      used only to note potential new DNCP nodes, and to notify that a
      unicast exchange should be triggered, the multicast transport does
      not have to be particularly secure.</t>

      <section title="Trickle-Driven Status Update Messages"
               anchor="trickle-updates">

        <t>Each node MUST send either <xref target="long-net-message">Long
        Network State Update message</xref> or <xref
        target="short-net-message">Short Network State Update
        message</xref> every time the link-specific <xref
        target="RFC6206">Trickle algorithm</xref> instance indicates they
        should to a link. The destination address of the message should be
        multicast in case of a link which is an actual interface, or unicast
        address of the remote party in case of link which is point-to-point.

        By default, Long Network State Update message SHOULD be used,
        but if the it is defined as undesirable for some case by the DNCP
        profile, Short Network State Update message MUST be sent
        instead. This may occur due to e.g. exceeding MTU for UDP multicast
        and not preferring to send fragmented packets.</t>

        <t>Trickle state MUST be maintained separately for each
        link. Trickle state for all links is considered inconsistent and
        reset if and only if the locally calculated network state hash
        changes. This occurs due to either change in the local node's own
        TLV data, or due to receipt of more recent data from another
        node.</t>

        <t>Trickle algorithm has 3 parameters; Imin, Imax and k. Imin and
        Imax represent minimum and maximum values for I, which is the time
        interval during which at least k Trickle updates must be seen on a
        link to prevent local state transmission.  Actual suggested Trickle
        algorithm parameters are DNCP profile specific, as described in
        <xref target="profile-bits"/>. </t>

      </section>

      <section title="Periodic Keep-Alive Messages" anchor="keep-alive">

        <t>In addition to the Trickle-driven messages, which provide for
        handling of both new peer detection (if applicable) on a link, as
        well as state change notification, another mechanism may be needed
        to get rid of old, no longer valid DNCP peers.</t>

        <t>If keep-alives are specified in the DNCP profile, based either
        on the whole link or per DNCP peer, if no other traffic has been
        sent to the particular destination within DNCP_KEEPALIVE_INTERVAL,
        <xref target="long-net-message">Long Network State Update
        message</xref> or <xref target="short-net-message">Short Network
        State Update message</xref> MUST be sent to that destination. The
        type of message should be chosen based on considerations in <xref
        target="trickle-updates" />. When such a message is sent, a new
        Trickle transmission time 't' MUST be randomly chosen in [I/2,
        I]. </t>

      </section>

      <section title="Received Message Processing" anchor="reception">

        <t><!--The majority of status updates among known nodes are
        initially triggered by reception of the <xref
        target="trickle-updates">Trickle-driven updates </xref>. -->This
        section describes processing of received messages, and how to react
        to them. The DNCP profile may specify criteria based on which
        received messages are ignored. The 'reply' mentioned in the steps
        means sending the specified unicast message to the originator of
        the message being processed. </t>

        <t>Upon receipt of:
	<list>

          <t><xref target="short-net-message">Short Network State
          Update</xref>:

          If the network state hash within the message differs from the
          locally calculated network state hash, receiver MUST reply with a
          <xref target="req-net-message">Network State Request
          message</xref>.
          </t>

          <t><xref target="long-net-message">Long Network State
          Update</xref>:

          <list style="symbols">
            <t>If the network state hash within the message matches the
            locally calculated network state hash, stop processing.</t>

            <t>If not, receiver MUST identify nodes for which local
            information is outdated (local update sequence number is lower
            than that within the message), potentially incorrect (local
            update sequence number is same and the hash of node data TLV
            differs) or missing.</t>

            <t>If any such nodes are identified, receiver MUST reply with a
            <xref target="req-node-message">Node Data Reply message</xref>
            containing <xref target="req-node-data">Request Node Data
            TLV(s)</xref> for the corresponding nodes.</t>

          </list>
          </t>

          <t><xref target="req-net-message">Network State Request</xref>:
          receiver MUST reply with a <xref target="long-net-message">Long
          Network State Update</xref>.</t>

          <t><xref target="req-node-message">Node Data Request</xref>:
          receiver MUST reply with the requested data in a <xref
          target="reply-node-message">Node Data Reply
          message</xref>. Optionally, if specified by the DNCP profile,
          multiple replies may be sent if it helps to (for example) keep
          each datagram's size within PMTU to the destination. These
          packets must be valid stand-alone Node Data Reply messages, with
          full state for particular nodes.</t>

          <t><xref target="reply-node-message">Node Data Reply</xref>: If the
          message contains Node State TLVs that are more recent than local
          state (higher update sequence number, different node data TLV hash, or
          missing altogether), and if the message also contains
          corresponding Node Data TLVs, update locally stored state. </t>
	</list>
	</t>

        <t>If a message containing <xref target="node-state">Node State
        TLVs</xref> is received with the node's own node identifier and a
        higher update sequence number than current local value, or the same
        update sequence number and different hash, there is an error
        somewhere. DNCP profile should provide guidance on how to handle
        this.</t>

      </section>

      <section title="Adding and Removing Peers" anchor="neighbor">

        <t>If a <xref target="req-net-message">Network State Request</xref>
        or a <xref target="req-node-message">Node Data Request</xref> is
        received on a link from another node, the node should be added as a
        DNCP peer on the link, and <xref target="neighbor-tlv">Neighbor
        TLV</xref> should be created for it. </t>

        <t>For every peer on every link, if no traffic is received from it
        within DNCP_TIMEOUT_INTERVAL, the Neighbor TLV and the local DNCP
        peer state MUST be removed. </t>
      </section>

      <section title="Purging Unreachable Nodes">

        <t>When a Neighbor TLV or whole node is added or removed, neighbor
        graph SHOULD be traversed for each node following the bidirectional
        neighbor relationships. These are identified by looking for
        Neighbor TLVs on both nodes, that have the other node's identifier
        in the neighbor node identifier, and local and neighbor link
        identifiers swapped. Each node reached should be marked
        currently reachable.</t>

        <t>DNCP nodes SHOULD be purged eventually if they have not been
        reachable within DNCP_GRACE_INTERVAL. During the grace period, the
        nodes that were not marked reachable in the most recent graph
        traversal MUST NOT be used for calculation of network state hash,
        or even be provided to any applications that need to use the whole
        TLV graph. </t>

      </section>

    </section>

    <section title="Protocol Messages">

      <t>For point-to-point exchanges, DNCP can run across unreliable
      datagram and reliable ordered stream transport. If using stream
      transport, a fixed, network-order 32 bit value indicating the
      number of bytes in that particular message MUST be sent before
      the actual message itself so that the receiving party can decode
      the individual messages as needed. The length value MUST include
      also the length of itself, so it essentially has minimum of 4.</t>

      <t>DNCP messages are encoded as a concatenated sequence of <xref
      target="tlvs">Type-Length-Value objects</xref>. In order to
      facilitate fast comparing of local state with that in a received
      message update, all TLVs in every encoding scope (either within the
      message itself, or within a container TLV) MUST be placed in
      ascending order based on the binary comparison of both TLV header
      and value. By design, the TLVs which MUST be present have the
      lowest available type values, ensuring they will naturally occur at
      the start of the Protocol Message, resembling a fixed format
      preamble.
      </t>

      <t>Any other TLVs than the ones specified in this section for a
      particular message MUST NOT cause an error, and SHOULD be silently
      ignored on receipt. DNCP profiles MAY therefore add extra TLVs (or
      even messages) as needed. </t>

      <section title="Short Network State Update Message"
               anchor="short-net-message">

        <t>TBD - describe</t>

        <t>The following TLVs MUST be present:
        <list style="symbols">

          <t><xref target="node-id">Node Link TLV</xref>.</t>

          <t><xref target="net-hash">Network State TLV</xref>.</t>

        </list>
        </t>
        <t>Short Network Status update MUST NOT contain any <xref
        target="node-state">Node State TLV(s)</xref>.</t>
      </section>

      <section title="Long Network State Update Message"
               anchor="long-net-message">

        <t>TBD - describe</t>

        <t>The following TLVs MUST be present:
        <list style="symbols">

          <t><xref target="node-id">Node Link TLV</xref>.</t>

          <t><xref target="net-hash">Network State TLV</xref>.</t>

        </list>
        </t>

	<t>The Long Network State Update message MUST include all <xref
	target="node-state">Node State TLVs</xref> included in the network
	state hash calculated most recently by the local node.</t>

      </section>

      <section title="Network State Request Message"
               anchor="req-net-message">

        <t>Network State Request requests receiver(s) to provide the local
        DNCP node with <xref target="long-net-message">Long Network State
        Update message</xref>.</t>

        <t>The following TLVs MUST be present:
        <list style="symbols">

          <t><xref target="node-id">Node Link TLV</xref>.</t>

          <t><xref target="req-net-hash">Request Network State
          TLV</xref>.</t>

        </list>
        </t>

      </section>

      <section title="Node Data Request Message"
               anchor="req-node-message">

        <t>Node Data Request requests receiver(s) to send a <xref
        target="reply-node-message">Node Data Reply message</xref> to the
        local DNCP node, which contains data of nodes with node identifier
        specified in the Request Node Data TLVs.</t>

        <t>The following TLVs MUST be present:
        <list style="symbols">

          <t><xref target="node-id">Node Link TLV</xref>.</t>

          <t>one or more <xref
          target="req-node-data">Request Node Data TLVs</xref>.</t>

        </list>
        </t>

      </section>

      <section title="Node Data Reply Message"
               anchor="reply-node-message">

        <t>The following TLVs MUST be present:
        <list style="symbols">
          <t><xref target="node-id">Node Link TLV</xref>.</t>

          <t>one or more <xref target="node-state">Node State TLV</xref>
          and <xref target="node-data">Node Data TLV</xref> pairs with
          have matching node identifier.</t>

        </list>
        </t>

        <t>Node Data Reply responds to <xref
        target="req-node-message">Node Data Request message</xref>.</t>

      </section>
    </section>

    <section anchor="tlvs" title="Type-Length-Value Objects">
      <t>
        Every TLV is encoded as 2 octet type, followed by 2 octet length
        (of the whole TLV, including header; 4 means no value), and then
        the value itself (if any). If the length is not divisible by 4,
        zeroed padding bytes MUST be inserted at the end of TLV. The length
        of padding bytes MUST NOT be included in the length field.
      </t>

      <figure>
        <artwork>
0                   1                   2                   3
0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|            Type               |           Length              |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                             Value                             |
|                     (variable # of bytes)                     |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        </artwork>
      </figure>

      <t>
        For example, encoding of type=123 (0x7b) TLV with value 'x' (120 =
        0x78):

        007B 0005 7800 0000
      </t>

      <t>Notation:
      <list>
        <t>.. = octet string concatenation operation</t>
        <t>H(x) = hash function specified by DNCP profile</t>
        <t>H-64(x) = H(x) truncated by taking just first 64 bits of the result.</t>
      </list>
      </t>


      <section title="Request TLVs">

        <section anchor="req-net-hash" title="Request Network State TLV">

          <figure>
            <artwork>
0                   1                   2                   3
0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|  Type: REQ-NETWORK-STATE (2)  |           Length: 4           |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            </artwork>
          </figure>

          <t>This TLV is used to identify <xref
          target="req-net-message">Network State Request
          message</xref>.</t>

        </section>
        <section anchor="req-node-data" title="Request Node Data TLV">


          <figure>
            <artwork>
0                   1                   2                   3
0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|    Type: REQ-NODE-DATA (3)    |          Length: 20           |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                        node identifier                        |
|                  (length fixed in DNCP profile)               |
                               ...
|                                                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            </artwork>
          </figure>

          <t>This TLV is used within <xref
          target="req-node-message">Node Data Request message</xref> to
          request node ientifier-specific data, if any, to be included in
          the <xref target="reply-node-message">Node Data Reply
          message</xref>.</t>

        </section>

      </section>
      <section title="Data TLVs">
        <section anchor="node-id" title="Node Link TLV">

          <figure>
            <artwork>
0                   1                   2                   3
0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|      Type: NODE-LINK (1)      |          Length: 24           |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                        node identifier                        |
|                  (length fixed in DNCP profile)               |
                            ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                        Link Identifier                        |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            </artwork>
          </figure>

          <t>This TLV identifies both the local node's node identifier, as
          well as the particular link identifier. It MUST be sent in all
          messages.</t>
        </section>
        <section anchor="net-hash" title="Network State TLV">

          <figure>
            <artwork>
0                   1                   2                   3
0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|    Type: NETWORK-STATE (4)    |          Length: 20           |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|          H(H(node data TLV 1) .. H(node data TLV N))          |
|                  (length fixed in DNCP profile)               |
                            ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            </artwork>
          </figure>

          <t>The Node Data TLVs are ordered for hashing by octet comparison
          of the corresponding node identifier hashes in ascending
          order.</t>

        </section>
        <section anchor="node-state" title="Node State TLV">

          <figure>
            <artwork>
0                   1                   2                   3
0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|      Type: NODE-STATE (5)     |          Length: 44           |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                        node identifier                        |
|                  (length fixed in DNCP profile)               |
                            ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                    Update Sequence Number                     |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                Milliseconds since Origination                 |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                        H(node data TLV)                       |
|                  (length fixed in DNCP profile)               |
                            ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            </artwork>
          </figure>

          <t>The whole network should have roughly the same idea about the
          time since origination. Therefore even the originating node should
          increment the time whenever it needs to send a new Node State TLV
          regarding itself without changing the corresponding Node Data
          TLV. This age value is not included within the Node Data TLV,
          however, as that is immutable and used to detect changes in the
          network state.</t>

        </section>
        <section anchor="node-data" title="Node Data TLV">

          <figure>
            <artwork>
0                   1                   2                   3
0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|      Type: NODE-DATA (6)      |        Length: >= 24          |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                        node identifier                        |
|                  (length fixed in DNCP profile)               |
                            ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                    Update Sequence Number                     |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|            Nested TLVs containing node information            |
            </artwork>
          </figure>

        </section>

        <section anchor="neighbor-tlv" title="Neighbor TLV (within Node Data TLV)">
	  <figure>
            <artwork>
0                   1                   2                   3
0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|       Type: NEIGHBOR (8)      |          Length: 28           |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                    neighbor node identifier                   |
|                  (length fixed in DNCP profile)               |
                            ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                    Neighbor Link Identifier                   |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                      Local Link Identifier                    |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            </artwork>
          </figure>

          <t>This TLV indicates that the node in question vouches that the
          specified neighbor is reachable by it on the local link id given.

          The presence of this TLV at least guarantees that the node
          publishing it has received traffic from the neighbor
          recently. For guaranteed bidirectional reachability, existence of
          both nodes' matching Neighbor TLVs should be checked. </t>
        </section>

      </section>

      <section anchor="user-tlv" title="Custom TLV (within/without Node Data TLV)">
	<figure>
          <artwork>
0                   1                   2                   3
0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|     Type: CUSTOM-DATA (9)     |         Length: >= 12         |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                            H-64(URI)                          |
|                                                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                          Opaque Data                          |
          </artwork>
        </figure>

        <t>This TLV can be used to contain anything; the URI used should be
        under control of the author of that specification.
        For example:</t>

        <t>V=H-64('http://example.com/author/json-for-hncp') .. '{"cool": "json
        extension!"}'</t>

        <t>or</t>

        <t>V=H-64('mailto:author@example.com') .. '{"cool": "json
        extension!"}'</t>

      </section>

    </section>


    <section title="Security and Trust Management">

      <t>If specified in the DNCP profile, either <xref
      target="RFC6347">DTLS</xref> or <xref target="RFC2246">TLS</xref>
      MUST be used to authenticate and encrypt either some (if specified
      optional in the profile), or all unicast traffic. The following
      methods for establishing trust are defined, but it is up to DNCP
      profile to specify which ones should be supported.</t>


      <section title="Pre-Shared Key Based Trust Method">

    	<t>A PSK-based trust model is a simple security management
    	mechanism that allows an administrator to deploy devices to an
    	existing network by configuring them with a pre-defined key,
    	similar to the configuration of an administrator password or
    	WPA-key.  Although limited in nature it is useful to provide a
    	user-friendly security mechanism for smaller networks. </t>

      </section>

      <section title="PKI Based Trust Method">

    	<t>A PKI-based trust-model enables more advanced management
    	capabilities at the cost of increased complexity and
    	bootstrapping effort. It however allows trust to be managed in a
    	centralized manner and is therefore useful for larger networks
    	with a need for an authoritative trust management.</t>
      </section>

      <section title="Certificate Based Trust Consensus Method">

    	<t>The certificate-based consensus model is designed to be a
    	compromise between trust management effort and flexibility. It is
    	based on X.509-certificates and allows each DNCP node to provide a
    	verdict on any other certificate and a consensus is found to
    	determine whether a node using this certificate or any
    	certificate signed by it is to be trusted. </t>

	<t>The current effective trust verdict for any certificate is
	defined as the one with the highest priority from all verdicts
	announced for said certificate at the time.</t>

    	<section title="Trust Verdicts">

	  <t>Trust Verdicts are statements of DNCP nodes about the
	  trustworthiness of X.509-certificates.  There are 5 possible
	  verdicts in order of ascending priority:

	  <list style="hanging">

	    <t hangText="0 Neutral">: no verdict exists but the DNCP
	    network should determine one.</t>

	    <t hangText="1 Cached Trust">: the last known effective verdict
	    was Configured or Cached Trust.</t>

	    <t hangText="2 Cached Distrust">: the last known effective
	    verdict was Configured or Cached Distrust.</t>

	    <t hangText="3 Configured Trust">: trustworthy based upon an
	    external ceremony or configuration.</t>

	    <t hangText="4 Configured Distrust">: not trustworthy based upon
	    an external ceremony or configuration.</t>

	  </list>
	  </t>

	  <t>
	    Verdicts are differentiated in 3 groups:

	    <list style="symbols">
	      <t>Configured verdicts are used to announce explicit verdicts
	      a node has based on any external trust bootstrap or
	      predefined relation a node has formed with a given
	      certificate.</t>

	      <t>Cached verdicts are used to retain the last known trust
	      state in case all nodes with configured verdicts about a
	      given certificate have been disconnected or turned off.</t>

	      <t>The Neutral verdict is used to announce a new node
	      intending to join the homenet so a final verdict for it can
	      be found.</t>
	    </list>
	  </t>

	  <t>
	    The current effective trust verdict for any certificate is
	    defined as the one with the highest priority from all verdicts
	    announced for said certificate at the time.

	    A node MUST be trusted for participating in the DNCP network if
	    and only if the current effective verdict for its own
	    certificate or any one in its certificate hierarchy is (Cached
	    or Configured) Trust and none of the certificates in its
	    hierarchy have an effective verdict of (Cached or Configured)
	    Distrust.

	    In case a node has a configured verdict which is different
	    from the current effective verdict for a certificate the
	    current effective verdict takes precedence in deciding
	    trustworthiness however the node still retains and announces
	    its configured verdict.
	  </t>
    	</section>

    	<section title="Trust Cache">
    	  <t>Each node SHOULD maintain a trust cache containing the current
    	  effective trust verdicts for all certificates currently announced
    	  in the DNCP network. This cache is used as a backup of the last
    	  known state in case there is no node announcing an configured
    	  verdict for a known certificate.  It SHOULD be saved to a
    	  non-volatile memory at reasonable time intervals to survive a
    	  reboot or power outage.</t>

    	  <t>Every time a node (re)joins the homenet or detects the change
    	  of an effective trust verdict for any certificate it will
    	  synchronize its cache, i.e.  store new effective verdicts
    	  overwriting any previously cached verdicts.  Configured verdicts
    	  are stored in the cache as their respective cached counterparts,
    	  Neutral verdicts are never stored. Neutral verdicts do not
    	  override existing cached verdicts.</t>
    	</section>

    	<section title="Announcement of Verdicts">
    	  <t>A node SHOULD always announce any configured trust verdicts it has
    	  established by itself.  It also announces cached trust verdicts
    	  it has stored in its trust cache if one of the following
    	  conditions applies:

    	  <list style="symbols">
    	    <t>The stored verdict is Cached Trust and the current effective
    	    verdict is Neutral or does not exist.</t>
    	    <t>The stored verdict is Cached Distrust and the current
    	    effective verdict is Cached Trust.</t>
    	  </list>

    	  A node rechecks these conditions whenever it detects changes of
    	  announced trust verdicts anywhere in the network.
    	  </t>

	  <t>Upon encountering a node with a hierarchy of certificates for
	  which there is no effective verdict a node adds a Neutral
	  Trust-Verdict-TLV to its node data for all certificates found in
	  the hierarchy until an effective verdict different from Neutral
	  can be found for any of the certificates or a reasonable amount
	  of time (10 minutes is suggested) with no reaction and no further
	  DTLS or TLS authentication attempts has passed.  Such verdicts
	  SHOULD also be limited in rate and number to prevent
	  denial-of-service attacks.</t>

    	  <t>Trust verdicts are announced using Trust-Verdict TLVs:
	  <figure>
	    <artwork>
0                   1                   2                   3
0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|   Type: Trust-Verdict (10)    |        Length: 41-104         |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|    Verdict    |                 (reserved)                    |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                                                               |
|                                                               |
|                                                               |
|                      SHA-256 Fingerprint                      |
|                                                               |
|                                                               |
|                                                               |
|                                                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                          Common Name                          |
	    </artwork>
	  </figure>

	  <list>
	    <t>Verdict represents the numerical index of the verdict.</t>

	    <t>(reserved) is reserved for future additions and MUST be set
	    to 0 when creating TLVs and ignored when parsing them.</t>

	    <t>SHA-256 Fingerprint contains the <xref
	    target="RFC6234">SHA-256</xref> hash-value of the certificate
	    in DER-format.</t>

	    <t>Common Name contains the variable-length (1-64 bytes) common
	    name of the certificate including a trailing 0-Byte.</t>
	  </list>
	  </t>
	</section>

	<section title="Bootstrap Ceremonies">
    	  <t>The following non-exhaustive list of methods describes
    	  possible ways to establish trust relationships between
    	  DNCP nodes and node certificates. Trust establishment is a
    	  two-way process in which the existing homenet must trust the
    	  newly added node and the newly added node must trust at least
    	  one of its neighboring nodes.

    	  It is therefore necessary that both the newly added node and an
    	  already trusted node perform such a ceremony to successfully
    	  introduce a node into the DNCP network.  In all cases an
    	  administrator MUST be provided with external means to identify
    	  the node belonging to a certificate based on its fingerprint
    	  and a meaningful common name.</t>

	  <section title="Trust by Identification">
    	    <t>A node implementing certificate-based trust MUST provide
    	    an interface to retrieve the current set of effective trust
    	    verdicts, fingerprints and names of all certificates currently
    	    known and set configured trust verdicts to be
    	    announced. Alternatively it MAY provide a companion DNCP node
    	    or application with these capabilities with which it has a
    	    pre-established trust relationship.</t>
    	  </section>

    	  <section title="Preconfigured Trust">
    	    <t>A node MAY be preconfigured to trust a certain set of
    	    node or CA certificates.  However such trust relationships
    	    MUST NOT result in unwanted or unrelated trust for nodes not
    	    intended to be run inside the same network (e.g. all other
    	    devices by the same manufacturer).</t>
    	  </section>

    	  <section title="Trust on Button Press">
    	    <t>A node MAY provide a physical or virtual interface to put
    	    one or more of its internal network interfaces temporarily into
    	    a mode in which it trusts the certificate of the first
    	    DNCP node it can successfully establish a connection
    	    with.</t>
    	  </section>

    	  <section title="Trust on First Use">
    	    <t>A node which is not associated with any other DNCP node MAY
    	    trust the certificate of the first DNCP node it can
    	    successfully establish a connection with. This method MUST NOT
    	    be used when the node has already associated with any other
    	    DNCP node.</t>
    	  </section>
    	</section>
      </section>
    </section>

    <section anchor="profile-bits" title="DNCP Profile-Specific Definitions">
      <!-- TBD - Pierre has a point - should define guidance on these,
           perhaps -->
      <t>Each DNCP profile MUST define following:
      <list style="symbols">

        <t>How it is secured:
        <list>
          <t>Not at all,</t>
          <t>optionally or always with TLS scheme defined here using one or
          more of the methods, or</t>
          <t>with something else.</t>
        </list>

        Given that links containing DNCP nodes can be sufficiently
        secured or isolated it is possible to run DNCP in a secure manner
        without using any form of authentication or encryption.
        </t>

        <t>Unicast and optionally multicast transport protocol(s) to be
        used. If TLS scheme within this document is to be used security,
        TLS or DTLS support for the transport protocols is mandatory.</t>

        <!-- TBD HNCP-03 IPv6 (ink-local UDP -->

        <t>Transport protocols' parameters such as port numbers to be used,
        or multicast address to be used. Unicast, multicast, and secure
        unicast may each require different paremeters, if applicable. </t>

        <t>When receiving messages, what sort of messages are dropped, as
        specified in <xref target="reception" />.</t>

<!--
     TBD HNCP-03
     HNCP is designed to operate between directly connected neighbors on a
     shared link using link-local IPv6 addresses. If the source address of
     a received HNCP packet is not an IPv6 link-local unicast address, the
     packet SHOULD be dropped. Similarly, if the destination address is not
     IPv6 link-local unicast or IPv6 link-local multicast address, packet
     SHOULD be dropped.
-->

        <t>What is the criteria for sending Trickle-based <xref
        target="long-net-message">Long Network State Update message</xref>
        on a link or to a DNCP peer.</t>

        <!-- TBD HNCP-03 .. when the message would be of <= X size. -->

        <t>How to deal with node identifier collision as described in <xref
        target="reception" />. Main options are either for one or both
        nodes to assign new node identifiers to themselves, or to notify
        someone about a fatal error condition in the DNCP network.</t>

<!-- HNCP-03 TBD

        <t>A recommended default way to handle this is to attempt to assert
        local state by increasing the local update sequence number to a
        value higher than that received and republish node data using the
        same node identifier. If this happens more than 3 times in 60
        seconds and the local node identifier is not globally unique, there
        may be more than one router with the same node identifier on the
        network. If there is no global guarantee of unique node identifier,
        a new node identifier SHOULD be generated and node data republished
        accordingly. </t>

-->

        <t>Imin, Imax and k ranges to be suggested for implementations to
        be used in the Trickle algorithm. Trickle algorithm does not
        require these to be same across all implementations for it to work,
        but similar orders of magnitude helps implementations of a DNCP
        profile to behave more consistently and to facilitate estimation of
        lower and upper bounds for behavior of the network.</t>

<!-- TBD - for HNCP
     <list>
     <t>k=1 SHOULD be used, as given the timer reset on data updates,
     retransmissions should handle packet loss.</t>

     <t>Imax MUST be at least one minute.</t>

     <t>Imin MUST be at least 200 milliseconds (earliest transmissions
     may occur at Imin/2 = 100 milliseconds given minimum values as
     per the Trickle algorithm).</t>
     </list>
-->
        <t>Whether to send keepalives, and if so, on link (=multicast) or
        to peers (=unicast).</t>

        <t>Hash function H(x) to be used, and how many bits of the input
        are actually used. The chosen hash function is used to handle both
        hashing of node specific data, and network state hash, which is a
        hash of node specific data hashes. SHA-256 defined in <xref
        target="SHS" /> is the recommended default choice.</t>

        <t>DNCP_KEEPALIVE_INTERVAL: How often keep-alive messages are to be
        sent (if enabled).</t>

        <t>DNCP_TIMEOUT_INTERVAL: How long a node may not be heard from to
        be considered still viable.</t>

        <t>DNCP_GRACE_INTERVAL: How long node data for unreachable node is
        kept.</t>

        <t>DNCP_NODE_IDENTIFIER_LENGTH: The fixed length a node
        identifier.</t>
        <!-- TBD for HNCP: 32 + no semantics -->

      </list>
      </t>
    </section>

    <section title="Security Considerations">

      <t>DNCP profiles may use multicast to indicate per-link changes of
      DNCP state or for keep-alive purposes, but they will not send any
      actual TLVs over that channel. An attacker may learn hash-values of
      the state within DNCP and may be able to trigger unicast
      synchronization attempts between nodes on a local link this way. A
      DNCP node should therefore rate-limit its reactions to multicast
      packets.</t>


      <t>The Certificate-based trust consensus mechanism defined in this
      document allows for a consenting revocation, however in case of a
      compromised device the trust cache may be poisoned before the actual
      revocation happens allowing the distrusted device to rejoin the
      network using a different identity.  Stopping such an attack might
      require physical intervention and flushing of the trust
      caches. However such an attack is often times more easily detectable
      than threats discussed earlier in this document such as silent
      manipulation of routing information and related man-in-the-middle
      attacks.</t>
    </section>

    <section anchor="iana" title="IANA Considerations">

      <t>IANA should set up a registry (policy TBD) for DNCP TLV types,
      with following initial contents:</t>

      <t>0: Reserved (should not happen on wire)</t>
      <t>1: Node link</t>
      <t>2: Request network state</t>
      <t>3: Request node data</t>
      <t>4: Network state</t>
      <t>5: Node state</t>
      <t>6: Node data</t>
      <t>7: (unused - was node public key, but never implemented)</t>
      <t>8: Neighbor</t>
      <t>9: Custom</t>
      <t>10: Trust-Verdict</t>
      <t>11-31: reserved for future DNCP versions.</t>

    </section>

  </middle>
  <back>
    <references title="Normative references">
      <?rfc include="reference.RFC.2119.xml"?>
      <?rfc include="reference.RFC.6206.xml"?>
      <?rfc include="reference.RFC.6347.xml"?>
      <?rfc include="reference.RFC.2246.xml"?>
    </references>
    <references title="Informative references">
      <?rfc include="reference.RFC.6234.xml"?>
      <reference anchor="SHS">
        <front>
          <title>Secure Hash Standard (SHS)</title>

          <author>
            <organization>National Institute of Standards and
            Technology</organization>
          </author>

          <date month="March" year="2012" />
        </front>
        <seriesInfo name="FIPS" value="PUB 180-4" />
        <format target="http://csrc.nist.gov/publications/fips/fips180-4/fips-18
0-4.pdf" type="PDF" />
      </reference>
    </references>
    <section title="Some Outstanding Issues">
      <t>None?</t>
    </section>

    <section title="Some Obvious Questions and Answers">
      <t>Q: Should there be nested container syntax that is actually
      self-describing? (i.e. type flag that indicates container, no body
      except sub-TLVs?)</t>

      <t>A: Not for now, but perhaps valid design.. TBD.</t>

      <t>Q: Add third case for multicast - 'medium' network state, which is
      'long' one, but partial?</t>
      <t>A: Drops typical convergence on large networks 5->3 packets, at
      expense of some specification/implementation complexity.</t>

      <t>Q: 32-bit link id?</t>

      <t>A: Here, it would save 32 bits per neighbor if it was 16 bits (and
      less is not realistic). However, TLVs defined elsewhere would not
      seem to even gain that much on average.  32 bits is also used for
      ifindex in various operating systems, making for simpler
      implementation.</t>

      <t>Q: Why not doing (performance thing X, Y or Z)?</t>

      <t>A: This is designed mostly to be minimal (only timers Trickle
      ones; everything triggered by Trickle-driven messages or local state
      changes). However, feel free to suggest better (even more minimal)
      design which works. </t>

    </section>
    <section title="Changelog">

      <t>draft-stenberg-homenet-dncp-00: Split from pre-version of
      draft-ietf-homenet-hncp-03 generic parts. </t>

    </section>

    <section title="Draft Source">
      <t>As usual, this draft is available at <eref
      target="https://github.com/fingon/ietf-drafts/">https://github.com/fingon/ietf-drafts/</eref>
      in source format (with nice Makefile too). Feel free to send comments
      and/or pull requests if and when you have changes to it! </t>
    </section>

    <section title="Acknowledgements">

      <t>Thanks to Ole Troan, Pierre Pfister, Mark Baugher, Mark Townsley,
      Juliusz Chroboczek and Jiazi Yi for their contributions to the
      draft.</t>

    </section>

  </back>
</rfc>
