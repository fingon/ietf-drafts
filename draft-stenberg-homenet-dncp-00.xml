<?xml version='1.0' ?>
<!--
Created:       Mon Nov 18 17:55:22 2013 mstenber

split from draft-ietf-homenet-hncp-03-pre - generic parts

TBD:

- proactive 'push' MAY/SHOULD?

- consider if node state + data should be merged like Pierre suggested

- think about short node state, ~medium long state, full long state
( probably not worth it, as in secure mode, not really worth it )

-->

<!DOCTYPE rfc SYSTEM 'rfc2629.dtd'>

<?rfc autobreaks="yes"?>
<?rfc compact="yes"?>
<?rfc strict='yes'?>
<?rfc subcompact="no"?>
<?rfc symrefs="yes"?>
<?rfc toc="yes"?>
<?rfc tocindent="yes"?>

<rfc
    ipr='trust200902'
    docName='draft-stenberg-homenet-dncp-00'
    category='std'
    >
  <front>
    <title abbrev="Distributed Node Consensus Protocol">
      Distributed Node Consensus Protocol
    </title>
    <author initials="M" surname="Stenberg" fullname="Markus Stenberg">
      <address>
        <postal>
          <street/>
          <city>Helsinki</city>
          <code>00930</code>
          <country>Finland</country>
        </postal>
        <email>markus.stenberg@iki.fi</email>
      </address>
    </author>
    <author initials="S" surname="Barth" fullname="Steven Barth">
      <address>
        <postal>
          <street/>
          <city>Halle</city>
          <code>06114</code>
          <country>Germany</country>
        </postal>
        <email>cyrus@openwrt.org</email>
      </address>
    </author>
    <date month="October" year="2014" />

    <area>Internet</area>
    <workgroup>Homenet Working Group</workgroup>
    <keyword>Homenet</keyword>
    <abstract>

      <t>This document describes the Distributed Node Consensus Protocol
      (DNCP), a generic state synchronization protocol using Trickle and
      Merkle trees. DNCP is transport agnostic and leaves some of the
      details to be defined or specified in profiles, which define actual
      implementable protocols based on DNCP. </t>

    </abstract>
  </front>
  <middle>
    <section title="Introduction">

      <t>DNCP is designed to provide a way for nodes to publish data
      consisting of an ordered set of TLV (Type-Length-Value) tuples, and
      to receive the data published by all other reachable DNCP nodes.</t>

      <t>DNCP has relatively few requirements for the underlying transport;
      it requires some way of transmitting either unicast datagram or
      stream data to a DNCP peer, and if used in multicast mode, a way of
      sending multicast datagrams. If security is desired and one of the
      built-in security methods is to be used, support for some TLS-derived
      transport scheme, such as <xref target="RFC5246">TLS</xref> on top of
      TCP, or <xref target="RFC6347">DTLS</xref> on top of UDP, is also
      required. </t>

    </section>

    <section anchor="kwd" title='Requirements Language'>

      <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL
      NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED",  "MAY", and
      "OPTIONAL" in this document are to be interpreted as described in
      <xref target='RFC2119'>RFC 2119</xref>.</t>

    </section>

    <section title="Terminology">
      <t>DNCP profile is a definition of a set of rules and
      values listed in <xref target="profile-bits"/> specifying the
      behavior of a DNCP based protocol, such as the used transport
      method.  For readability, any DNCP profile specific parameters
      with profile-specific fixed value are prefixed with DNCP_.</t>

      <t>DNCP node is a single node which runs a protocol
      based on a DNCP profile.</t>

      <t>DNCP network is a set of DNCP nodes running the
      same DNCP profile that can reach each other, either via learned
      shared connections in the underlying network, or by knowing
      address of each other. As DNCP exchanges are bidirectional, DNCP
      nodes connected via only unidirectional links are not considered
      connected. </t>

      <t>(DNCP) peer refers to another DNCP node with which
      a DNCP node communicates directly.</t>

      <t>Node identifier is an opaque fixed-length
      identifier of DNCP_NODE_IDENTIFIER_LENGTH bytes which uniquely
      identifies a DNCP node in a DNCP network. </t>

      <t>Link indicates a link-layer media over which
      directly connected nodes can communicate.</t>

      <t>Interface indicates a port of a node that is
      directly connected to a particular link. </t>

      <t>Connection denotes a locally configured use
      of DNCP on a DNCP node, that is attached either to an interface,
      or to a specific remote unicast address.</t>

      <t>Connection identifier is a 32-bit opaque value, which identifies
      locally uniquely particular connection of that particular DNCP
      node. Value of 0 is reserved for DNCP and sub-protocol purposes in
      the TLVs, and MUST NOT be used to identify an actual connection.</t>

      <t>Node data is a set of TLVs published by a node in
      the DNCP network.</t>

      <t>Node state is a set of metadata attributes for
      node data.  It includes a sequence number for versioning, a
      hash-value for comparing and a timestamp indicating the time
      passed since its last publication.</t>

      <t>Network state (hash) is a hash-value representing
      the current state of the network.  The function and the number of
      bits used from the function defined in the DNCP profile.

      Whenever any node is added, removed or changes its published node
      data this hash-value changes as well. It is calculated over the
      hash-values of each reachable nodes' node data in ascending order
      of the respective node identifier.</t>

      <t>Effective (trust) verdict for any certificate is
      defined as the one with the highest priority from all verdicts
      announced for said certificate at the time in the DNCP
      network.</t>

    </section>

    <section anchor="dm" title="Data Model">

      <t>A DNCP node has for every DNCP node in the DNCP network:

      <list style="symbols">

        <t>A node identifier.</t>

        <t>The node data, an ordered set of TLV tuples it published by that
        particular node. This set of TLVs has a well-defined order based on
        ascending binary content (including TLV type and length). This
        facilitates linear time state delta processing. </t>

        <t>The latest update sequence number, a 32 bit number that is
        incremented any time the TLV set is published. For comparison
        purposes, a looping comparison should be used to avoid problems in
        case of overflow. An example would be: a &lt; b &lt;=&gt; (a - b)
        % 2^32 &amp; 2^31 != 0.</t>

        <t>The relative time (in milliseconds) since last publishing of the
        current TLV data set with the current update sequence number. It is
        also 32 bit number on the wire.  If this number is close to
        overflow (greater than 2^32-2^16), a node MUST re-publish it's TLVs
        even if there is no change to avoid overflow of the value.</t>

      </list>
      </t>

      <t>Additionally, a DNCP node has a set of connections for which DNCP
      is configured to be used. For each such connection, a node has:

      <list style="symbols">
        <t>A connection identifier.</t>

        <t>An interface, or an unicast address of a DNCP peer it is
        connected to.</t>

        <t>A <xref target="RFC6206">Trickle</xref> instance with parameters
        I, T, and c.</t>
      </list>
      </t>

      <t>For each DNCP peer detected on a connection, a DNCP node has:

      <list style="symbols">

        <t>The connection identifier of the DNCP peer.</t>

        <t>The most recent address used by the DNCP peer (in an
        authenticated message, if security is enabled).</t>

      </list>
      </t>

    </section>

    <section title="Operation">

      <t>The DNCP protocol consists of <xref target="RFC6206">Trickle</xref>
      driven unicast or multicast status messages which indicate the current
      status of shared TLV data, and additional unicast message exchanges
      which ensure DNCP peer reachability and synchronize the data when
      necessary. </t>

      <t>If DNCP is to be used on a multicast-capable interface, as opposed
      to only point-to-point using known unicast remote address, a
      datagram-based transport which supports multicast SHOULD be defined
      in the DNCP profile to be used for the messages to be sent to the
      whole link. As this is used only to identify potential new DNCP
      nodes, and to notify that an unicast exchange should be triggered,
      the multicast transport does not have to be particularly secure.</t>

      <section title="Trickle-Driven Status Update Messages"
               anchor="trickle-updates">

        <t>Each node MUST send either a <xref
        target="long-net-message">Long Network State Update message</xref>
        or a <xref target="short-net-message">Short Network State Update
        message</xref> every time the connection-specific <xref
        target="RFC6206">Trickle algorithm</xref> instance indicates that
        an update should be sent.
        The destination address of the message should be multicast in case
        of an interface which is multicast-capable, or the unicast address
        of the remote party in case of a point-to-point connection.

        By default, Long Network State Update messages SHOULD be used,
        but if it is defined as undesirable for some case by the DNCP
        profile, Short Network State Update message MUST be sent
        instead. This may be useful to avoid fragmenting packets to multicast
        destinations.</t>

        <t>A Trickle state MUST be maintained separately for each
        connection. The Trickle state for all connections is considered
        inconsistent and reset if and only if the locally calculated
        network state hash changes. This occurs due to a change in the
        local node's own node data, or due to receipt of more recent data
        from another node.</t>

        <t>The Trickle algorithm has 3 parameters; Imin, Imax and k. Imin
        and Imax represent the minimum and maximum values for I, which is
        the time interval during which at least k Trickle updates must be
        seen on a connection to prevent local state transmission.  The
        actual suggested Trickle algorithm parameters are DNCP profile
        specific, as described in <xref target="profile-bits"/>.</t>

      </section>

      <section title="Processing of Received Messages" anchor="reception">

        <t>This section describes how received messages are processed.  The
        DNCP profile may specify criteria based on which received messages
        are ignored. Any 'reply' mentioned in the steps below denotes
        sending of the specified message via unicast to the originator of
        the message being processed. If replying to a multicast message
        using a link with shared bandwidth, reply SHOULD be delayed random
        interval in [0, Imin/2].</t>

        <t>Upon receipt of:
        <list>

          <t><xref target="short-net-message">Short Network State
          Update</xref>:

          If the network state hash within the message differs from the
          locally calculated network state hash, the receiver MUST reply
          with a <xref target="req-net-message">Network State Request
          message</xref>.
          </t>

          <t><xref target="long-net-message">Long Network State
          Update</xref>:

          <list style="symbols">
            <t>If the network state hash within the message matches the
            locally calculated network state hash, stop processing.</t>

            <t>Otherwise the receiver MUST identify nodes for which local
            information is outdated (local update sequence number is lower
            than that within the message), potentially incorrect (local
            update sequence number matches but the hash of the node data TLV
            differs) or missing.</t>

            <t>If any such nodes are identified, the receiver MUST reply
            with a <xref target="req-node-message">Node Data Request
            message</xref> containing <xref target="req-node-data">Request
            Node Data TLV(s)</xref> for the corresponding nodes.</t>

          </list>
          </t>

          <t><xref target="req-net-message">Network State Request</xref>:
          the receiver MUST reply with a <xref
          target="long-net-message">Long Network State Update</xref>. </t>

          <t><xref target="req-node-message">Node Data Request</xref>: the
          receiver MUST reply with the requested data in a <xref
          target="reply-node-message">Node Data Reply
          message</xref>. Optionally - if specified by the DNCP profile -
          multiple replies MAY be sent in order to e.g. keep size of each
          datagram within the PMTU to the destination. However these
          replies must be valid stand-alone Node Data Reply messages, with
          the full state for the particular nodes.</t>

          <t><xref target="reply-node-message">Node Data Reply</xref>: If
          the message contains Node State TLVs that are more recent than
          the local state (higher update sequence number, different node
          data TLV hash, or missing altogether), and if the message also
          contains corresponding Node Data TLVs, the receiver MUST update
          its locally stored state.</t>
        </list>
        </t>

        <t>If a message containing <xref target="node-state">Node State
        TLVs</xref> is received with the node identifier matching the local
        node identifier and a higher update sequence number than its
        current local value, or the same update sequence number and a
        different hash, the node SHOULD re-publish its own node data with an
        update sequence number 1000 higher than the received one. This may
        occur normally once due to local node restarting, and not storing
        the most recently used update sequence number. If this occurs more
        than once, the DNCP profile should provide guidance on how to
        handle these situations as it indicates existence of a second
        active node on the network with the same node identifier.</t>

      </section>

      <section title="Adding and Removing Peers" anchor="neighbor">

        <t>When receiving a message on a connection from unknown peer:
        <list>
          <t>If it is a unicast message, the remote node MUST be added as a
          peer on the connection and a <xref target="neighbor-tlv">Neighbor
          TLV</xref> MUST be created for it.
          </t>

          <t>If it is a multicast message, the remote node SHOULD be sent
          (possibly rate-limited) unicast <xref
          target="req-net-message">Network State Request
          Message</xref>.</t>
        </list>
        </t>

        <t>If keep-alives are NOT sent by the peer (either DNCP profile
        does not specify use of keep-alives, or the particular peer chooses
        not to send keep-alive messages), some other means MUST be employed
        to ensure DNCP peer is present, and when the peer is no longer
        present, the Neighbor TLV and the local DNCP peer state MUST be
        removed.</t>
      </section>

      <section title="Purging Unreachable Nodes">

        <t>When a Neighbor TLV or a whole node is added or removed, the
        neighbor graph SHOULD be traversed for each node following the
        bidirectional neighbor relationships. These are identified by
        looking for Neighbor TLVs on both nodes, that have the other node's
        identifier in the neighbor node identifier, and local and neighbor
        connection identifiers swapped. Each node reached should be marked
        currently reachable.</t>

        <t>DNCP nodes SHOULD be purged eventually if they have not been
        reachable within DNCP_GRACE_INTERVAL. During the grace period, the
        nodes that were not marked reachable in the most recent graph
        traversal MUST NOT be used for calculation of network state hash,
        or even be provided to any applications that need to use the whole
        TLV graph. </t>

      </section>

    </section>

    <section anchor="ka" title="Keep-Alive Extension">

      <t>The basic Trickle-driven messages provide for handling of both new
      peer detection (if applicable) on a connection as well as state
      change notification, however another mechanism may be needed to get
      rid of old, no longer valid DNCP peers.</t>

      <t>If keep-alives are not specified in the DNCP profile, the rest of
      this section MUST be ignored.</t>

      <t>A DNCP profile MAY specify either per-connection or per-peer
      keep-alive support. This document specifies only per-connection
      keep-alive, thus if per-peer support is required either a lower layer
      mechanism or a definition within the profile is required.</t>

      <section title="Data Model Additions">

        <t>The following additions to the <xref target="dm">Data
        Model</xref> are needed to support keep-alive:</t>

        <t>Each node MUST have a timestamp which indicates the last time a
        <xref target="net-state">Network State TLV</xref> was sent for each
        connection, i.e. on a physical interface or to the point-to-point
        peer.</t>

        <t>Each node MUST have for each peer:

        <list style="symbols">

          <t>Last consistent state timestamp: a timestamp which indicates
          the last time a consistent <xref target="net-state">Network State
          TLV</xref> was received from the peer. When adding a new peer, it
          should be initialized to the current time.</t>

        </list>
        </t>

      </section>

      <section title="Periodic Keep-Alive Messages" anchor="keep-alive">

        <t>For every connection that a keep-alive is specified for in the
        DNCP profile, the connection-specific keep-alive interval MUST be
        maintained. By default, it is DNCP_KEEPALIVE_INTERVAL. If there is
        a local value that is preferred for that for any reason
        (configuration, energy conservation, media type, ..), it should be
        substituted instead. If non-default keep-alive interval is used on
        any connection, DNCP node MUST publish appropriate <xref
        target="ka-interval">Keep-Alive Interval TLV(s)</xref>.</t>

        <t>If no traffic containing a <xref target="net-state">Network
        State TLV</xref> has been sent to a particular connection within
        the connection-specific keep-alive interval, a <xref
        target="long-net-message">Long Network State Update message</xref>
        or a <xref target="short-net-message">Short Network State Update
        message</xref> MUST be sent on that connection. The type of message
        should be chosen based on the considerations in <xref
        target="trickle-updates" />. When such a message is sent, a new
        Trickle transmission time 't' in [I/2, I] MUST be randomly
        chosen.</t>

      </section>

      <section title="Received Message Processing Additions">

        <t>If the received message contains a <xref
        target="net-state">Network State TLV</xref> which is consistent
        with the locally calculated network state hash, the
        Last consistent state timestamp for the peer MUST be updated.</t>

      </section>

      <section title="Neighbor Removal">
        <t>For every peer on every connection, their connection-specific
        keep-alive interval must be calculated by looking for <xref
        target="ka-interval">Keep-Alive Interval TLVs</xref> published by
        the peer, and if none exist, using default value of
        DNCP_KEEPALIVE_INTERVAL. If the peer's last consistent state
        timestamp has not been updated for at least
        DNCP_KEEPALIVE_MULTIPLIER times peer's connection-specific
        keep-alive interval, the Neighbor TLV for that peer and the local
        DNCP peer state MUST be removed.</t>
      </section>

    </section>

    <section title="Protocol Messages">

      <t>For point-to-point exchanges, DNCP can run across
      datagram-based or reliable ordered stream-based transports.
      If a stream-based transport is used, a 32-bit length-value
      in network byte order is sent before each message to indicate the
      number of bytes the following message consists of.</t>

      <t>DNCP messages are encoded as a concatenated sequence of <xref
      target="tlvs">Type-Length-Value objects</xref>. In order to
      facilitate fast comparing of local state with that in a received
      message update, all TLVs in every encoding scope (either within the
      message itself, or within a container TLV) MUST be placed in
      ascending order based on the binary comparison of both TLV header
      and value. By design, the TLVs which MUST be present have the
      lowest available type values, ensuring they will naturally occur at
      the start of the Protocol Message, resembling a fixed format
      preamble.
      </t>

      <t>DNCP profiles MAY add additional TLVs to the message specified
      here or even additional messages as needed.</t>

      <section title="Short Network State Update Message"
               anchor="short-net-message">

        <t>The Short Network State Update Message is used to announce the
        sender's view of the network state using multicast.</t>

        <t>The following TLVs MUST be present:
        <list style="symbols">

          <t>One <xref target="node-id">Node Connection TLV</xref> identifying
          the originating node and connection.</t>

          <t>One <xref target="net-state">Network State TLV</xref>
          containing the network state hash as calculated by the
          sender.</t>

        </list>
        </t>
        <t>The Short Network Status update message MUST NOT contain any <xref
        target="node-state">Node State TLV(s)</xref>.</t>

      </section>

      <section title="Long Network State Update Message"
               anchor="long-net-message">

        <t>The Long Network State Update Message is used to announce the
        sender's view of the network state and all node states using
        multicast or unicast.</t>

        <t>The following TLVs MUST be present:
        <list style="symbols">

          <t>One <xref target="node-id">Node Connection TLV</xref> identifying
          the originating node and connection.</t>

          <t>One <xref target="net-state">Network State TLV</xref>
          containing the network state hash as calculated by the
          sender.</t>

          <t>One or more <xref target="node-state">Node State TLVs</xref>
          containing the node state of DNCP nodes as currently known to the
          sender.</t>

        </list>
        </t>

        <t>The Long Network State Update message MUST include the
        corresponding <xref target="node-state">Node State TLV</xref> for
        each Node Data TLV used to calculate the network state hash.</t>

      </section>

      <section title="Network State Request Message"
               anchor="req-net-message">

        <t>The Network State Request message is used to request the
        recipient's view of the network state and all node states currently
        known to it.</t>

        <t>The following TLVs MUST be present:
        <list style="symbols">

          <t>One <xref target="node-id">Node Connection TLV</xref> identifying
          the originating node and connection.</t>

          <t>One <xref target="req-net-state">Request Network State
          TLV</xref> indicating the type of request.</t>

        </list>
        </t>

      </section>

      <section title="Node Data Request Message"
               anchor="req-node-message">

        <t>The Node Data Request message is used to request the node state
        and data of one or more DNCP nodes in the network.</t>

        <t>The following TLVs MUST be present:
        <list style="symbols">

          <t>One <xref target="node-id">Node Connection TLV</xref> identifying
          the originating node and connection.</t>

          <t>One or more <xref target="req-node-data">Request Node Data
          TLVs</xref> indicating the nodes for which state and data is
          requested.</t>

        </list>
        </t>

      </section>

      <section title="Node Data Reply Message"
               anchor="reply-node-message">

        <t>The Node Data Request message is used to provide
        the node data of one or more DNCP nodes in the network.</t>

        <t>The following TLVs MUST be present:
        <list style="symbols">

          <t>One <xref target="node-id">Node Connection TLV</xref> identifying
          the originating node and connection.</t>

          <t>One or more <xref target="node-state">Node State TLV</xref>
          and <xref target="node-data">Node Data TLV</xref> pairs with
          matching node identifiers for each node previously requested in a
          <xref target="req-node-message">Node Data Request
          message</xref>.</t>

        </list>
        </t>

      </section>
    </section>

    <section anchor="tlvs" title="Type-Length-Value Objects">
      <t>
        Each TLV is encoded as a 2 byte type-field, followed by a 2-byte
        length-field (of the value, excluding header; 0 means no value)
        followed by the value itself (if any). Both type and length fields
        in the header as well as all integer fields inside the value
        - unless explicitly stated otherwise - are
        represented in network byte order. Zero padding bytes MUST be added
        up to the next 4-byte boundary if the length is not divisible by 4.
        These padding bytes MUST NOT be included in the length field.
      </t>

      <figure>
        <artwork>
0                   1                   2                   3
0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|            Type               |           Length              |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                             Value                             |
|                     (variable # of bytes)                     |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        </artwork>
      </figure>

      <t>
        For example, encoding of type=123 (0x7b) TLV with value 'x' (120 =
        0x78):

        007B 0005 7800 0000
      </t>

      <t>Notation:
      <list>

        <t>.. = octet string concatenation operation</t>

        <t>H(x) = hash function specified by DNCP profile</t>

        <t>H-64(x) = H(x) truncated by taking the first 64 bits of the
        result.</t>

      </list>
      </t>


      <section title="Request TLVs">

        <section anchor="req-net-state" title="Request Network State TLV">

          <figure>
            <artwork>
0                   1                   2                   3
0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|  Type: REQ-NETWORK-STATE (2)  |           Length: 0           |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            </artwork>
          </figure>

          <t>This TLV is used to identify a <xref
          target="req-net-message">Network State Request
          message</xref>.</t>

        </section>
        <section anchor="req-node-data" title="Request Node Data TLV">


          <figure>
            <artwork>
0                   1                   2                   3
0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|    Type: REQ-NODE-DATA (3)    |          Length: >0           |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                        node identifier                        |
|                  (length fixed in DNCP profile)               |
...
|                                                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            </artwork>
          </figure>

          <t>This TLV is used within a <xref
          target="req-node-message">Node Data Request message</xref> to
          request node state and node data, if any, to be included in
          a subsequent <xref target="reply-node-message">Node Data Reply
          message</xref>.</t>

        </section>

      </section>
      <section title="Data TLVs">
        <section anchor="node-id" title="Node Connection TLV">

          <figure>
            <artwork>
0                   1                   2                   3
0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|   Type: NODE-CONNECTION (1)   |          Length: > 4          |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                        node identifier                        |
|                  (length fixed in DNCP profile)               |
...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                     Connection Identifier                     |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            </artwork>
          </figure>

          <t>This TLV identifies both the local node's node identifier, as
          well as the particular connection identifier. It MUST be sent in all
          messages.</t>
        </section>
        <section anchor="net-state" title="Network State TLV">

          <figure>
            <artwork>
0                   1                   2                   3
0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|    Type: NETWORK-STATE (4)    |          Length: > 0          |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|          H(H(node data TLV 1) .. H(node data TLV N))          |
|                  (length fixed in DNCP profile)               |
...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            </artwork>
          </figure>

          <t>The network state hash is derived by calculating the
          hash-value for each currently reachable node's Node Data TLV,
          concatenating said hash-values based on the ascending order of
          their corresponding node identifiers and hashing the resulting
          concatenated hash-values.</t>

        </section>
        <section anchor="node-state" title="Node State TLV">

          <figure>
            <artwork>
0                   1                   2                   3
0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|      Type: NODE-STATE (5)     |          Length: > 8          |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                        node identifier                        |
|                  (length fixed in DNCP profile)               |
...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                    Update Sequence Number                     |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                Milliseconds since Origination                 |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                        H(node data TLV)                       |
|                  (length fixed in DNCP profile)               |
...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            </artwork>
          </figure>

          <t>The whole network should have roughly the same idea about the
          time since origination. Therefore even the originating node should
          increment the time whenever it needs to send a new Node State TLV
          regarding itself without changing the corresponding Node Data
          TLV. This age value is not included within the Node Data TLV,
          however, as that is immutable and used to detect changes in the
          network state.</t>

        </section>
        <section anchor="node-data" title="Node Data TLV">

          <figure>
            <artwork>
0                   1                   2                   3
0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|      Type: NODE-DATA (6)      |         Length: > 4           |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                        node identifier                        |
|                  (length fixed in DNCP profile)               |
...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                    Update Sequence Number                     |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|            Nested TLVs containing node information            |
            </artwork>
          </figure>

        </section>

        <section anchor="neighbor-tlv"
                 title="Neighbor TLV (within Node Data TLV)">
          <figure>
            <artwork>
0                   1                   2                   3
0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|       Type: NEIGHBOR (7)      |          Length: > 8          |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                    neighbor node identifier                   |
|                  (length fixed in DNCP profile)               |
...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                 Neighbor Connection Identifier                |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                   Local Connection Identifier                 |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            </artwork>
          </figure>

          <t>This TLV indicates that the node in question vouches that the
          specified neighbor is reachable by it on the specified local
          connection.

          The presence of this TLV at least guarantees that the node
          publishing it has received traffic from the neighbor
          recently. For guaranteed up-to-date bidirectional reachability,
          existence of both nodes' matching Neighbor TLVs should be
          checked. </t>
        </section>

        <section anchor="ka-interval"
                 title="Keep-Alive Interval TLV (within Node Data TLV)">

          <figure>
            <artwork>
0                   1                   2                   3
0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
| Type: KEEP-ALIVE-INTERVAL (8) |          Length: 4            |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                     Connection Identifier                     |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                           Interval                            |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            </artwork>
          </figure>

          <t>This TLV is used indicate a non-default interval used to send
          keep-alive messages specified in <xref target="ka" />.</t>

          <t>Connection identifier is used to identify the particular
          connection for which the interval applies. If 0, it applies for
          ALL connections for which no specific TLV exists.</t>

          <t>Interval specifies the interval in milliseconds at which the
          node sends keep-alives. Value of zero means no keep-alives are
          sent at all; in that case, some lower layer mechanism that
          ensures presence of nodes MUST be available and used. </t>
        </section>

      </section>

      <section anchor="user-tlv"
               title="Custom TLV (within/without Node Data TLV)">
        <figure>
          <artwork>
0                   1                   2                   3
0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|     Type: CUSTOM-DATA (9)     |         Length: >= 8          |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                            H-64(URI)                          |
|                                                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                          Opaque Data                          |
          </artwork>
        </figure>

        <t>This TLV can be used to contain anything; the URI used should be
        under control of the author of that specification.
        For example:</t>

        <t>V=H-64('http://example.com/author/json-for-dncp') .. '{"cool":
        "json extension!"}'</t>

        <t>or</t>

        <t>V=H-64('mailto:author@example.com') .. '{"cool": "json
        extension!"}'</t>

      </section>

    </section>


    <section title="Security and Trust Management">

      <t>If specified in the DNCP profile, either <xref
      target="RFC6347">DTLS</xref> or <xref target="RFC5246">TLS</xref>
      MUST be used to authenticate and encrypt either some (if specified
      optional in the profile), or all unicast traffic. The following
      methods for establishing trust are defined, but it is up to the DNCP
      profile to specify which ones should be supported.</t>


      <section title="Pre-Shared Key Based Trust Method">

        <t>A PSK-based trust model is a simple security management
        mechanism that allows an administrator to deploy devices to an
        existing network by configuring them with a pre-defined key,
        similar to the configuration of an administrator password or
        WPA-key.  Although limited in nature it is useful to provide a
        user-friendly security mechanism for smaller networks. </t>

      </section>

      <section title="PKI Based Trust Method">

        <t>A PKI-based trust-model enables more advanced management
        capabilities at the cost of increased complexity and
        bootstrapping effort. It however allows trust to be managed in a
        centralized manner and is therefore useful for larger networks
        with a need for an authoritative trust management.</t>
      </section>

      <section title="Certificate Based Trust Consensus Method">

        <t>The certificate-based consensus model is designed to be a
        compromise between trust management effort and flexibility. It is
        based on X.509-certificates and allows each DNCP node to provide a
        verdict on any other certificate and a consensus is found to
        determine whether a node using this certificate or any
        certificate signed by it is to be trusted. </t>

        <t>The current effective trust verdict for any certificate is
        defined as the one with the highest priority from all verdicts
        announced for said certificate at the time.</t>

        <section title="Trust Verdicts">

          <t>Trust Verdicts are statements of DNCP nodes about the
          trustworthiness of X.509-certificates.  There are 5 possible
          verdicts in order of ascending priority:

          <list style="hanging">

            <t hangText="0 Neutral">: no verdict exists but the DNCP
            network should determine one.</t>

            <t hangText="1 Cached Trust">: the last known effective verdict
            was Configured or Cached Trust.</t>

            <t hangText="2 Cached Distrust">: the last known effective
            verdict was Configured or Cached Distrust.</t>

            <t hangText="3 Configured Trust">: trustworthy based upon an
            external ceremony or configuration.</t>

            <t hangText="4 Configured Distrust">: not trustworthy based upon
            an external ceremony or configuration.</t>

          </list>
          </t>

          <t>
            Verdicts are differentiated in 3 groups:

            <list style="symbols">
              <t>Configured verdicts are used to announce explicit verdicts
              a node has based on any external trust bootstrap or
              predefined relation a node has formed with a given
              certificate.</t>

              <t>Cached verdicts are used to retain the last known trust
              state in case all nodes with configured verdicts about a
              given certificate have been disconnected or turned off.</t>

              <t>The Neutral verdict is used to announce a new node
              intending to join the homenet so a final verdict for it can
              be found.</t>
            </list>
          </t>

          <t>
            The current effective trust verdict for any certificate is
            defined as the one with the highest priority from all verdicts
            announced for said certificate at the time.

            A node MUST be trusted for participating in the DNCP network if
            and only if the current effective verdict for its own
            certificate or any one in its certificate hierarchy is (Cached
            or Configured) Trust and none of the certificates in its
            hierarchy have an effective verdict of (Cached or Configured)
            Distrust.

            In case a node has a configured verdict which is different
            from the current effective verdict for a certificate the
            current effective verdict takes precedence in deciding
            trustworthiness however the node still retains and announces
            its configured verdict.
          </t>
        </section>

        <section title="Trust Cache">
          <t>Each node SHOULD maintain a trust cache containing the current
          effective trust verdicts for all certificates currently announced
          in the DNCP network. This cache is used as a backup of the last
          known state in case there is no node announcing a configured
          verdict for a known certificate.  It SHOULD be saved to a
          non-volatile memory at reasonable time intervals to survive a
          reboot or power outage.</t>

          <t>Every time a node (re)joins the homenet or detects the change
          of an effective trust verdict for any certificate it will
          synchronize its cache, i.e.  store new effective verdicts
          overwriting any previously cached verdicts.  Configured verdicts
          are stored in the cache as their respective cached counterparts,
          Neutral verdicts are never stored. Neutral verdicts do not
          override existing cached verdicts.</t>
        </section>

        <section title="Announcement of Verdicts">
          <t>A node SHOULD always announce any configured trust verdicts it
          has established by itself, it MUST do so if announcing the
          configured trust verdict leads to a change in the current
          effective verdict for the respective certificate.  In absence of
          configured verdicts it MUST announce cached trust verdicts it has
          stored in its trust cache if one of the following conditions
          applies:

          <list style="symbols">
            <t>The stored verdict is Cached Trust and the current effective
            verdict for the certificate is Neutral or does not exist.</t>
            <t>The stored verdict is Cached Distrust and the current
            effective verdict for the certificate is Cached Trust.</t>
          </list>

          A node rechecks these conditions whenever it detects changes of
          announced trust verdicts anywhere in the network.
          </t>

          <t>Upon encountering a node with a hierarchy of certificates for
          which there is no effective verdict a node adds a Neutral
          Trust-Verdict-TLV to its node data for all certificates found in
          the hierarchy until an effective verdict different from Neutral
          can be found for any of the certificates or a reasonable amount
          of time (10 minutes is suggested) with no reaction and no further
          DTLS or TLS authentication attempts has passed.  Such verdicts
          SHOULD also be limited in rate and number to prevent
          denial-of-service attacks.</t>

          <t>Trust verdicts are announced using Trust-Verdict TLVs:
          <figure>
            <artwork>
0                   1                   2                   3
0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|   Type: Trust-Verdict (10)    |        Length: 37-100         |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|    Verdict    |                 (reserved)                    |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                                                               |
|                                                               |
|                                                               |
|                      SHA-256 Fingerprint                      |
|                                                               |
|                                                               |
|                                                               |
|                                                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                          Common Name                          |
            </artwork>
          </figure>

          <list>
            <t>Verdict represents the numerical index of the verdict.</t>

            <t>(reserved) is reserved for future additions and MUST be set
            to 0 when creating TLVs and ignored when parsing them.</t>

            <t>SHA-256 Fingerprint contains the <xref
            target="RFC6234">SHA-256</xref> hash-value of the certificate
            in DER-format.</t>

            <t>Common Name contains the variable-length (1-64 bytes) common
            name of the certificate including a trailing 0-Byte.</t>
          </list>
          </t>
        </section>

        <section title="Bootstrap Ceremonies">
          <t>The following non-exhaustive list of methods describes
          possible ways to establish trust relationships between
          DNCP nodes and node certificates. Trust establishment is a
          two-way process in which the existing homenet must trust the
          newly added node and the newly added node must trust at least
          one of its neighboring nodes.

          It is therefore necessary that both the newly added node and an
          already trusted node perform such a ceremony to successfully
          introduce a node into the DNCP network.  In all cases an
          administrator MUST be provided with external means to identify
          the node belonging to a certificate based on its fingerprint
          and a meaningful common name.</t>

          <section title="Trust by Identification">
            <t>A node implementing certificate-based trust MUST provide
            an interface to retrieve the current set of effective trust
            verdicts, fingerprints and names of all certificates currently
            known and set configured trust verdicts to be
            announced. Alternatively it MAY provide a companion DNCP node
            or application with these capabilities with which it has a
            pre-established trust relationship.</t>
          </section>

          <section title="Preconfigured Trust">
            <t>A node MAY be preconfigured to trust a certain set of
            node or CA certificates.  However such trust relationships
            MUST NOT result in unwanted or unrelated trust for nodes not
            intended to be run inside the same network (e.g. all other
            devices by the same manufacturer).</t>
          </section>

          <section title="Trust on Button Press">
            <t>A node MAY provide a physical or virtual interface to put
            one or more of its internal network interfaces temporarily into
            a mode in which it trusts the certificate of the first
            DNCP node it can successfully establish a connection
            with.</t>
          </section>

          <section title="Trust on First Use">
            <t>A node which is not associated with any other DNCP node MAY
            trust the certificate of the first DNCP node it can
            successfully establish a connection with. This method MUST NOT
            be used when the node has already associated with any other
            DNCP node.</t>
          </section>
        </section>
      </section>
    </section>

    <section anchor="profile-bits" title="DNCP Profile-Specific Definitions">
      <!-- TBD - Pierre has a point - should define guidance on these,
           perhaps -->
      <t>Each DNCP profile MUST define following:
      <list style="symbols">

        <t>DNCP_NODE_IDENTIFIER_LENGTH: The fixed length a node
        identifier (in bytes).</t>

        <t>DNCP_GRACE_INTERVAL: How long node data for unreachable nodes is
        kept.</t>

        <t>How it is secured:
        <list>
          <t>Not at all,</t>
          <t>optionally or always with TLS scheme defined here using one or
          more of the methods, or</t>
          <t>with something else.</t>
        </list>

        Given that links with DNCP nodes can be sufficiently
        secured or isolated it is possible to run DNCP in a secure manner
        without using any form of authentication or encryption.
        </t>

        <t>Unicast and optionally multicast transport protocol(s) to be
        used. If TLS scheme within this document is to be used security,
        TLS or DTLS support for the transport protocols is mandatory.</t>

        <t>Transport protocols' parameters such as port numbers to be used,
        or multicast address to be used. Unicast, multicast, and secure
        unicast may each require different parameters, if applicable. </t>

        <t>When receiving messages, what sort of messages are dropped, as
        specified in <xref target="reception" />.</t>

        <t>What is the criteria for sending Trickle-based <xref
        target="long-net-message">Long Network State Update message</xref>
        on an interface or to a DNCP peer.</t>

        <t>How to deal with node identifier collision as described in <xref
        target="reception" />. Main options are either for one or both
        nodes to assign new node identifiers to themselves, or to notify
        someone about a fatal error condition in the DNCP network.</t>

        <t>Imin, Imax and k ranges to be suggested for implementations to
        be used in the Trickle algorithm. Trickle algorithm does not
        require these to be same across all implementations for it to work,
        but similar orders of magnitude helps implementations of a DNCP
        profile to behave more consistently and to facilitate estimation of
        lower and upper bounds for behavior of the network.</t>

        <t>Hash function H(x) to be used, and how many bits of the input
        are actually used. The chosen hash function is used to handle both
        hashing of node specific data, and network state hash, which is a
        hash of node specific data hashes. SHA-256 defined in <xref
        target="RFC6234" /> is the recommended default choice.</t>

        <t>Whether to send keep-alives, and if so, on an interface, using
        multicast, or directly using unicast to peers. Keep-alive has also
        associated parameters:

        <list style="symbols">
          <t>DNCP_KEEPALIVE_INTERVAL: How often keep-alive messages are to be
          sent (if enabled).</t>

          <t>DNCP_KEEPALIVE_MULTIPLIER: How many times the
          DNCP_KEEPALIVE_INTERVAL (or peer-supplied keep-alive interval
          value) a node may not be heard from to be considered still
          valid.</t>
        </list>
        </t>
      </list>
    </t>
  </section>

  <section title="Security Considerations">

    <t>DNCP profiles may use multicast to indicate DNCP state changes and
    for keep-alive purposes. However, no actual data TLVs will be sent
    across that channel. Therefore an attacker may only learn hash-values
    of the state within DNCP and may be able to trigger unicast
    synchronization attempts between nodes on a local link this way. A DNCP
    node should therefore rate-limit its reactions to multicast
    packets.</t>

    <t>The Certificate-based trust consensus mechanism defined in this
    document allows for a consenting revocation, however in case of a
    compromised device the trust cache may be poisoned before the actual
    revocation happens allowing the distrusted device to rejoin the
    network using a different identity.  Stopping such an attack might
    require physical intervention and flushing of the trust
    caches. However such an attack is often times more easily detectable
    than threats discussed earlier in this document such as silent
    manipulation of routing information and related man-in-the-middle
    attacks.</t>
  </section>

  <section anchor="iana" title="IANA Considerations">

    <t>IANA should set up a registry (policy TBD) for DNCP TLV types,
    with following initial contents:</t>

    <t>0: Reserved (should not happen on wire)</t>
    <t>1: Node connection</t>
    <t>2: Request network state</t>
    <t>3: Request node data</t>
    <t>4: Network state</t>
    <t>5: Node state</t>
    <t>6: Node data</t>
    <t>7: Neighbor</t>
    <t>8: Keep-alive interval</t>
    <t>9: Custom</t>
    <t>10: Trust-Verdict</t>
    <t>11-31: Reserved for future DNCP versions.</t>

    <t>192-255: Reserved for per-implementation experimentation. The
    nodes using TLV types in this range SHOULD use e.g. Custom TLV to
    identify each other and therefore eliminate potential conflict caused
    by potential different use of same TLV numbers. </t>

  </section>

</middle>
<back>
  <references title="Normative references">
    <?rfc include="reference.RFC.2119.xml"?>
    <?rfc include="reference.RFC.6206.xml"?>
    <?rfc include="reference.RFC.6347.xml"?>
    <?rfc include="reference.RFC.5246.xml"?>
  </references>
  <references title="Informative references">
    <?rfc include="reference.RFC.6234.xml"?>
  </references>
  <section title="Some Outstanding Issues">
    <t>Should per-peer keep-alives be specified here? They are essentially
    constant unicast keep-alives, as opposed to unicast OR multicast
    per-connection ones are.</t>
  </section>

  <section title="Some Obvious Questions and Answers">
    <t>Q: Should there be nested container syntax that is actually
    self-describing? (i.e. type flag that indicates container, no body
    except sub-TLVs?)</t>

    <t>A: Not for now, but perhaps valid design.. TBD.</t>

    <t>Q: Add third case for multicast - 'medium' network state, which is
    'long' one, but partial?</t>
    <t>A: Drops typical convergence on large networks 5->3 packets, at
    expense of some specification/implementation complexity.</t>

    <t>Q: 32-bit connection id?</t>

    <t>A: Here, it would save 32 bits per neighbor if it was 16 bits (and
    less is not realistic). However, TLVs defined elsewhere would not
    seem to even gain that much on average.  32 bits is also used for
    ifindex in various operating systems, making for simpler
    implementation.</t>

    <t>Q: Why not doing (performance thing X, Y or Z)?</t>

    <t>A: This is designed mostly to be minimal (only timers Trickle
    ones; everything triggered by Trickle-driven messages or local state
    changes). However, feel free to suggest better (even more minimal)
    design which works. </t>

  </section>
  <section title="Changelog">

    <t>draft-stenberg-homenet-dncp-00: Split from pre-version of
    draft-ietf-homenet-hncp-03 generic parts. Changes that affect
    implementations:
    <list style="symbols">

      <t>TLVs were renumbered.</t>

      <t>TLV length does not include header (=-4). This facilitates
      e.g. use of DHCPv6 option parsing libraries (same encoding), and
      reduces complexity (no need to handle error values of length less
      than 4).</t>

      <t>Trickle is reset only when locally calculated network state hash
      is changes, not as remote different network state hash is seen. This
      prevents e.g. attacks by multicast with one multicast packet to force
      Trickle reset on every interface of every node on a link.</t>

      <t>Instead of 'ping', use 'keep-alive' (optional) for dead peer
      detection. Different message used!</t>

    </list>
    </t>

  </section>

  <section title="Draft Source">
    <t>As usual, this draft is available at <eref
    target="https://github.com/fingon/ietf-drafts/">
    https://github.com/fingon/ietf-drafts/</eref>
    in source format (with nice Makefile too). Feel free to send comments
    and/or pull requests if and when you have changes to it! </t>
  </section>

  <section title="Acknowledgements">

    <t>Thanks to Ole Troan, Pierre Pfister, Mark Baugher, Mark Townsley,
    Juliusz Chroboczek and Jiazi Yi for their contributions to the
    draft.</t>

  </section>

</back>
</rfc>
